[[testcontext-fixture-di]]
===== Dependency injection of test fixtures
When you use the `DependencyInjectionTestExecutionListener` -- which is configured by
default -- the dependencies of your test instances are __injected__ from beans in the
application context that you configured with `@ContextConfiguration`. You may use setter
injection, field injection, or both, depending on which annotations you choose and
whether you place them on setter methods or fields. For consistency with the annotation
support introduced in Spring 2.5 and 3.0, you can use Spring's `@Autowired` annotation
or the `@Inject` annotation from JSR 300.

[TIP]
====

The TestContext framework does not instrument the manner in which a test instance is
instantiated. Thus the use of `@Autowired` or `@Inject` for constructors has no effect
for test classes.
====

Because `@Autowired` is used to perform <<beans-factory-autowire, __autowiring by type__
>>, if you have multiple bean definitions of the same type, you cannot rely on this
approach for those particular beans. In that case, you can use `@Autowired` in
conjunction with `@Qualifier`. As of Spring 3.0 you may also choose to use `@Inject` in
conjunction with `@Named`. Alternatively, if your test class has access to its
`ApplicationContext`, you can perform an explicit lookup by using (for example) a call
to `applicationContext.getBean("titleRepository")`.

If you do not want dependency injection applied to your test instances, simply do not
annotate fields or setter methods with `@Autowired` or `@Inject`. Alternatively, you can
disable dependency injection altogether by explicitly configuring your class with
`@TestExecutionListeners` and omitting `DependencyInjectionTestExecutionListener.class`
from the list of listeners.

Consider the scenario of testing a `HibernateTitleRepository` class, as outlined in the
<<integration-testing-goals,Goals>> section. The next two code listings demonstrate the
use of `@Autowired` on fields and setter methods. The application context configuration
is presented after all sample code listings.

[NOTE]
====
The dependency injection behavior in the following code listings is not specific to
JUnit. The same DI techniques can be used in conjunction with any testing framework.

The following examples make calls to static assertion methods such as `assertNotNull()`
but without prepending the call with `Assert`. In such cases, assume that the method was
properly imported through an `import static` declaration that is not shown in the
example.
====

The first code listing shows a JUnit-based implementation of the test class that uses
`@Autowired` for field injection.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	// specifies the Spring configuration to load for this test fixture
	**@ContextConfiguration("repository-config.xml")**
	public class HibernateTitleRepositoryTests {

		// this instance will be dependency injected by type
		**@Autowired**
		private HibernateTitleRepository titleRepository;

		@Test
		public void findById() {
			Title title = titleRepository.findById(new Long(10));
			assertNotNull(title);
		}
	}
----

Alternatively, you can configure the class to use `@Autowired` for setter injection as
seen below.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	// specifies the Spring configuration to load for this test fixture
	**@ContextConfiguration("repository-config.xml")**
	public class HibernateTitleRepositoryTests {

		// this instance will be dependency injected by type
		private HibernateTitleRepository titleRepository;

		**@Autowired**
		public void setTitleRepository(HibernateTitleRepository titleRepository) {
			this.titleRepository = titleRepository;
		}

		@Test
		public void findById() {
			Title title = titleRepository.findById(new Long(10));
			assertNotNull(title);
		}
	}
----

The preceding code listings use the same XML context file referenced by the
`@ContextConfiguration` annotation (that is, `repository-config.xml`), which looks like
this:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd">

		<!-- this bean will be injected into the HibernateTitleRepositoryTests class -->
		<bean id="**titleRepository**" class="**com.foo.repository.hibernate.HibernateTitleRepository**">
			<property name="sessionFactory" ref="sessionFactory"/>
		</bean>

		<bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
			<!-- configuration elided for brevity -->
		</bean>

	</beans>
----

[NOTE]
====
If you are extending from a Spring-provided test base class that happens to use
`@Autowired` on one of its setter methods, you might have multiple beans of the affected
type defined in your application context: for example, multiple `DataSource` beans. In
such a case, you can override the setter method and use the `@Qualifier` annotation to
indicate a specific target bean as follows, but make sure to delegate to the overridden
method in the superclass as well.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	// ...

		@Autowired
		@Override
		public void setDataSource(**@Qualifier("myDataSource")** DataSource dataSource) {
			**super**.setDataSource(dataSource);
		}

	// ...
----

The specified qualifier value indicates the specific `DataSource` bean to inject,
narrowing the set of type matches to a specific bean. Its value is matched against
`<qualifier>` declarations within the corresponding `<bean>` definitions. The bean name
is used as a fallback qualifier value, so you may effectively also point to a specific
bean by name there (as shown above, assuming that "myDataSource" is the bean id).
====


[[testcontext-web-scoped-beans]]
===== Testing request and session scoped beans

<<beans-factory-scopes-other,Request and session scoped beans>> have been supported by
Spring for several years now, but it's always been a bit non-trivial to test them. As of
Spring 3.2 it's a breeze to test your request-scoped and session-scoped beans by
following these steps.

* Ensure that a `WebApplicationContext` is loaded for your test by annotating your test
  class with `@WebAppConfiguration`.
* Inject the mock request or session into your test instance and prepare your test
  fixture as appropriate.
* Invoke your web component that you retrieved from the configured
  `WebApplicationContext` (i.e., via dependency injection).
* Perform assertions against the mocks.

The following code snippet displays the XML configuration for a login use case. Note
that the `userService` bean has a dependency on a request-scoped `loginAction` bean.
Also, the `LoginAction` is instantiated using <<expressions,SpEL expressions>> that
retrieve the username and password from the current HTTP request. In our test, we will
want to configure these request parameters via the mock managed by the TestContext
framework.

.Request-scoped bean configuration
[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="userService"
				class="com.example.SimpleUserService"
				c:loginAction-ref="loginAction" />

		<bean id="loginAction" class="com.example.LoginAction"
				c:username="#{request.getParameter(''user'')}"
				c:password="#{request.getParameter(''pswd'')}"
				scope="request">
			<aop:scoped-proxy />
		</bean>

	</beans>
----

In `RequestScopedBeanTests` we inject both the `UserService` (i.e., the subject under
test) and the `MockHttpServletRequest` into our test instance. Within our
`requestScope()` test method we set up our test fixture by setting request parameters in
the provided `MockHttpServletRequest`. When the `loginUser()` method is invoked on our
`userService` we are assured that the user service has access to the request-scoped
`loginAction` for the current `MockHttpServletRequest` (i.e., the one we just set
parameters in). We can then perform assertions against the results based on the known
inputs for the username and password.

.Request-scoped bean test
[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	@ContextConfiguration
	@WebAppConfiguration
	public class RequestScopedBeanTests {

		@Autowired UserService userService;
		@Autowired MockHttpServletRequest request;

		@Test
		public void requestScope() {

			request.setParameter("user", "enigma");
			request.setParameter("pswd", "$pr!ng");

			LoginResults results = userService.loginUser();

			// assert results
		}
	}
----

The following code snippet is similar to the one we saw above for a request-scoped bean;
however, this time the `userService` bean has a dependency on a session-scoped
`userPreferences` bean. Note that the `UserPreferences` bean is instantiated using a
SpEL expression that retrieves the __theme__ from the current HTTP session. In our test,
we will need to configure a theme in the mock session managed by the TestContext
framework.

.Session-scoped bean configuration
[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="userService"
				class="com.example.SimpleUserService"
				c:userPreferences-ref="userPreferences" />

		<bean id="userPreferences"
				class="com.example.UserPreferences"
				c:theme="#{session.getAttribute(''theme'')}"
				scope="session">
			<aop:scoped-proxy />
		</bean>

	</beans>
----

In `SessionScopedBeanTests` we inject the `UserService` and the `MockHttpSession` into
our test instance. Within our `sessionScope()` test method we set up our test fixture by
setting the expected "theme" attribute in the provided `MockHttpSession`. When the
`processUserPreferences()` method is invoked on our `userService` we are assured that
the user service has access to the session-scoped `userPreferences` for the current
`MockHttpSession`, and we can perform assertions against the results based on the
configured theme.

.Session-scoped bean test
[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	@ContextConfiguration
	@WebAppConfiguration
	public class SessionScopedBeanTests {

		@Autowired UserService userService;
		@Autowired MockHttpSession session;

		@Test
		public void sessionScope() throws Exception {

			session.setAttribute("theme", "blue");

			Results results = userService.processUserPreferences();

			// assert results
		}
	}
----

[[testcontext-tx]]
===== Transaction management

In the TestContext framework, transactions are managed by the
`TransactionalTestExecutionListener` which is configured by default, even if you do not
explicitly declare `@TestExecutionListeners` on your test class. To enable support for
transactions, however, you must configure a `PlatformTransactionManager` bean in the
`ApplicationContext` that is loaded via `@ContextConfiguration` semantics (further
details are provided below). In addition, you must declare Spring's `@Transactional`
annotation either at the class or method level for your tests.

[[testcontext-tx-test-managed-transactions]]
====== Test-managed transactions

_Test-managed transactions_ are transactions that are managed _declaratively_ via the
`TransactionalTestExecutionListener` or _programmatically_ via `TestTransaction` (see
below). Such transactions should not be confused with _Spring-managed transactions_
(i.e., those managed directly by Spring within the `ApplicationContext` loaded for tests)
or _application-managed transactions_ (i.e., those managed programmatically within
application code that is invoked via tests). Spring-managed and application-managed
transactions will typically participate in test-managed transactions; however, caution
should be taken if Spring-managed or application-managed transactions are configured with
any _propagation_ type other than `REQUIRED` or `SUPPORTS` (see the discussion on
<<tx-propagation,transaction propagation>> for details).

[[testcontext-tx-enabling-transactions]]
====== Enabling and disabling transactions

Annotating a test method with `@Transactional` causes the test to be run within a
transaction that will, by default, be automatically rolled back after completion of the
test. If a test class is annotated with `@Transactional`, each test method within that
class hierarchy will be run within a transaction. Test methods that are not annotated
with `@Transactional` (at the class or method level) will not be run within a
transaction. Furthermore, tests that are annotated with `@Transactional` but have the
`propagation` type set to `NOT_SUPPORTED` will not be run within a transaction.

__Note that <<testcontext-support-classes-junit4,
`AbstractTransactionalJUnit4SpringContextTests`>> and
<<testcontext-support-classes-testng, `AbstractTransactionalTestNGSpringContextTests`>>
are preconfigured for transactional support at the class level.__

The following example demonstrates a common scenario for writing an integration test for
a Hibernate-based `UserRepository`. As explained in
<<testcontext-tx-rollback-and-commit-behavior>>, there is no need to clean up the
database after the `createUser()` method is executed since any changes made to the
database will be automatically rolled back by the `TransactionalTestExecutionListener`.
See <<testing-examples-petclinic>> for an additional example.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	@ContextConfiguration(classes = TestConfig.class)
	@Transactional
	public class HibernateUserRepositoryTests {

		@Autowired
		HibernateUserRepository repository;

		@Autowired
		SessionFactory sessionFactory;

		JdbcTemplate jdbcTemplate;

		@Autowired
		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		@Test
		public void createUser() {
			// track initial state in test database:
			final int count = countRowsInTable("user");

			User user = new User(...);
			repository.save(user);

			// Manual flush is required to avoid false positive in test
			sessionFactory.getCurrentSession().flush();
			assertNumUsers(count + 1);
		}

		protected int countRowsInTable(String tableName) {
			return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
		}

		protected void assertNumUsers(int expected) {
			assertEquals("Number of rows in the ''user'' table.", expected, countRowsInTable("user"));
		}
	}
----

[[testcontext-tx-rollback-and-commit-behavior]]
====== Transaction rollback and commit behavior

By default, test transactions will be automatically rolled back after completion of the
test; however, transactional commit and rollback behavior can be configured declaratively
via the class-level `@TransactionConfiguration` and method-level `@Rollback` annotations.
See the corresponding entries in the <<integration-testing-annotations,annotation
support>> section for further details.

[[testcontext-tx-programmatic-tx-mgt]]
====== Programmatic transaction management
As of Spring Framework 4.1, it is possible to interact with test-managed transactions
_programmatically_ via the static methods in `TestTransaction`. For example,
`TestTransaction` may be used within _test_ methods, _before_ methods, and _after_
methods to start or end the current test-managed transaction or to configure the current
test-managed transaction for rollback or commit. Support for `TestTransaction` is
automatically available whenever the `TransactionalTestExecutionListener` is enabled.

The following example demonstrates some of the features of `TestTransaction`. Consult the
javadocs for `TestTransaction` for further details.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@ContextConfiguration(classes = TestConfig.class)
	public class ProgrammaticTransactionManagementTests extends
			AbstractTransactionalJUnit4SpringContextTests {

		@Test
		public void transactionalTest() {
			// assert initial state in test database:
			assertNumUsers(2);

			deleteFromTables("user");

			// changes to the database will be committed!
			TestTransaction.flagForCommit();
			TestTransaction.end();
			assertFalse(TestTransaction.isActive());
			assertNumUsers(0);

			TestTransaction.start();
			// perform other actions against the database that will
			// be automatically rolled back after the test completes...
		}

		protected void assertNumUsers(int expected) {
			assertEquals("Number of rows in the ''user'' table.", expected, countRowsInTable("user"));
		}
	}
----

[[testcontext-tx-before-and-after-tx]]
====== Executing code outside of a transaction

Occasionally you need to execute certain code before or after a transactional test method
but outside the transactional context -- for example, to verify the initial database state
prior to execution of your test or to verify expected transactional commit behavior after
test execution (if the test was configured not to roll back the transaction).
`TransactionalTestExecutionListener` supports the `@BeforeTransaction` and
`@AfterTransaction` annotations exactly for such scenarios. Simply annotate any `public
void` method in your test class with one of these annotations, and the
`TransactionalTestExecutionListener` ensures that your __before transaction method__ or
__after transaction method__ is executed at the appropriate time.

[TIP]
====
Any __before methods__ (such as methods annotated with JUnit's `@Before`) and any __after
methods__ (such as methods annotated with JUnit's `@After`) are executed __within__ a
transaction. In addition, methods annotated with `@BeforeTransaction` or
`@AfterTransaction` are naturally not executed for test methods that are not configured
to run within a transaction.
====

[[testcontext-tx-mgr-config]]
====== Configuring a transaction manager

`TransactionalTestExecutionListener` expects a `PlatformTransactionManager` bean to be
defined in the Spring `ApplicationContext` for the test. In case there are multiple
instances of `PlatformTransactionManager` within the test's `ApplicationContext`,
`@TransactionConfiguration` supports configuring the bean name of the
`PlatformTransactionManager` that should be used to drive transactions. Alternatively, a
_qualifier_ may be declared via `@Transactional("myQualifier")`, or
`TransactionManagementConfigurer` can be implemented by an `@Configuration` class.
Consult the javadocs for `TestContextTransactionUtils.retrieveTransactionManager()` for
details on the algorithm used to look up a transaction manager in the test's
`ApplicationContext`.

[[testcontext-tx-annotation-demo]]
====== Demonstration of all transaction-related annotations

The following JUnit-based example displays a fictitious integration testing scenario
highlighting all transaction-related annotations. The example is **not** intended to
demonstrate best practices but rather to demonstrate how these annotations can be used.
Consult the <<integration-testing-annotations,annotation support>> section for further
information and configuration examples. <<testcontext-executing-sql-declaratively-tx,
Transaction management for `@Sql`>> contains an additional example using `@Sql` for
declarative SQL script execution with default transaction rollback semantics.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	@ContextConfiguration
	**@TransactionConfiguration(transactionManager="txMgr", defaultRollback=false)
	@Transactional**
	public class FictitiousTransactionalTest {

		**@BeforeTransaction**
		public void verifyInitialDatabaseState() {
			// logic to verify the initial state before a transaction is started
		}

		@Before
		public void setUpTestDataWithinTransaction() {
			// set up test data within the transaction
		}

		@Test
		// overrides the class-level defaultRollback setting
		**@Rollback(true)**
		public void modifyDatabaseWithinTransaction() {
			// logic which uses the test data and modifies database state
		}

		@After
		public void tearDownWithinTransaction() {
			// execute "tear down" logic within the transaction
		}

		**@AfterTransaction**
		public void verifyFinalDatabaseState() {
			// logic to verify the final state after transaction has rolled back
		}

	}
----

[[testcontext-tx-false-positives]]
.Avoid false positives when testing ORM code
[NOTE]
====
When you test application code that manipulates the state of the Hibernate session, make
sure to __flush__ the underlying session within test methods that execute that code.
Failing to flush the underlying session can produce __false positives__: your test may
pass, but the same code throws an exception in a live, production environment. In the
following Hibernate-based example test case, one method demonstrates a false positive,
and the other method correctly exposes the results of flushing the session. Note that
this applies to JPA and any other ORM frameworks that maintain an in-memory __unit of
work__.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	// ...

	@Autowired
	private SessionFactory sessionFactory;

	@Test // no expected exception!
	public void falsePositive() {
		updateEntityInHibernateSession();
		// False positive: an exception will be thrown once the session is
		// finally flushed (i.e., in production code)
	}

	@Test(expected = GenericJDBCException.class)
	public void updateWithSessionFlush() {
		updateEntityInHibernateSession();
		// Manual flush is required to avoid false positive in test
		sessionFactory.getCurrentSession().flush();
	}

	// ...
----
====


[[testcontext-executing-sql]]
===== Executing SQL scripts

When writing integration tests against a relational database, it is often beneficial
to execute SQL scripts to modify the database schema or insert test data into tables.
The `spring-jdbc` module provides support for _initializing_ an embedded or existing
database by executing SQL scripts when the Spring `ApplicationContext` is loaded. See
<<jdbc-embedded-database-support>> and <<jdbc-embedded-database-dao-testing>> for
details.

Although it is very useful to initialize a database for testing _once_ when the
`ApplicationContext` is loaded, sometimes it is essential to be able to modify the
database _during_ integration tests. The following sections explain how to execute SQL
scripts programmatically and declaratively during integration tests.

[[testcontext-executing-sql-programmatically]]
====== Executing SQL scripts programmatically

Spring provides the following options for executing SQL scripts programmatically within
integration test methods.

* `org.springframework.jdbc.datasource.init.ScriptUtils`
* `org.springframework.jdbc.datasource.init.ResourceDatabasePopulator`
* `org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests`
* `org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests`

`ScriptUtils` provides a collection of static utility methods for working with SQL scripts
and is mainly intended for internal use within the framework. However, if you require
full control over how SQL scripts are parsed and executed, `ScriptUtils` may suit your
needs better than some of the other alternatives described below. Consult the javadocs for
individual methods in `ScriptUtils` for further details.

`ResourceDatabasePopulator` provides a simple object-based API for programmatically
populating, initializing, or cleaning up a database using SQL scripts defined in
external resources. `ResourceDatabasePopulator` provides options for configuring the
character encoding, statement separator, comment delimiters, and error handling flags
used when parsing and executing the scripts, and each of the configuration options has
a reasonable default value. Consult the javadocs for details on default values. To
execute the scripts configured in a `ResourceDatabasePopulator`, you can invoke either
the `populate(Connection)` method to execute the populator against a
`java.sql.Connection` or the `execute(DataSource)` method to execute the populator
against a `javax.sql.DataSource`. The following example specifies SQL scripts for a test
schema and test data, sets the statement separator to `"@@"`, and then executes the
scripts against a `DataSource`.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Test
	public void databaseTest {
		ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
		populator.addScripts(
			new ClassPathResource("test-schema.sql"),
			new ClassPathResource("test-data.sql"));
		populator.setSeparator("@@");
		populator.execute(this.dataSource);
		// execute code that uses the test schema and data
	}
----

Note that `ResourceDatabasePopulator` internally delegates to `ScriptUtils` for parsing
and executing SQL scripts. Similarly, the `executeSqlScript(..)` methods in
<<testcontext-support-classes-junit4, `AbstractTransactionalJUnit4SpringContextTests`>> and
<<testcontext-support-classes-testng, `AbstractTransactionalTestNGSpringContextTests`>>
internally use a `ResourceDatabasePopulator` for executing SQL scripts. Consult the javadocs
for the various `executeSqlScript(..)` methods for further details.


[[testcontext-executing-sql-declaratively]]
====== Executing SQL scripts declaratively with `@Sql`

In addition to the aforementioned mechanisms for executing SQL scripts
_programmatically_, SQL scripts can also be configured _declaratively_ in the Spring
TestContext Framework. Specifically, the `@Sql` annotation can be declared on a test
class or test method to configure the resource paths to SQL scripts that should be
executed against a given database either before or after an integration test method. Note
that method-level declarations override class-level declarations and that support for
`@Sql` is provided by the `SqlScriptsTestExecutionListener` which is enabled by default.

*Path resource semantics*

Each path will be interpreted as a Spring `Resource`. A plain path -- for example,
`"schema.sql"` -- will be treated as a classpath resource that is _relative_ to the
package in which the test class is defined. A path starting with a slash will be treated
as an _absolute_ classpath resource, for example: `"/org/example/schema.sql"`. A path
which references a URL (e.g., a path prefixed with `classpath:`, `file:`, `http:`, etc.)
will be loaded using the specified resource protocol.

The following example demonstrates how to use `@Sql` at the class level and at the method
level within a JUnit-based integration test class.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	@ContextConfiguration
	@Sql("/test-schema.sql")
	public class DatabaseTests {

		@Test
		public void emptySchemaTest {
			// execute code that uses the test schema without any test data
		}

		@Test
		@Sql({"/test-schema.sql", "/test-user-data.sql"})
		public void userTest {
			// execute code that uses the test schema and test data
		}
	}
----

*Default script detection*

If no SQL scripts are specified, an attempt will be made to detect a `default` script
depending on where `@Sql` is declared. If a default cannot be detected, an
`IllegalStateException` will be thrown.

* __class-level declaration__: if the annotated test class is `com.example.MyTest`, the
	corresponding default script is `"classpath:com/example/MyTest.sql"`.
* __method-level declaration__: if the annotated test method is named `testMethod()` and is
	defined in the class `com.example.MyTest`, the corresponding default script is
	`"classpath:com/example/MyTest.testMethod.sql"`.

*Declaring multiple `@Sql` sets*

If multiple sets of SQL scripts need to be configured for a given test class or test
method but with different syntax configuration, different error handling rules, or
different execution phases per set, it is possible to declare multiple instances of
`@Sql`. With Java 8, `@Sql` can be used as a _repeatable_ annotation. Otherwise, the
`@SqlGroup` annotation can be used as an explicit container for declaring multiple
instances of `@Sql`.

The following example demonstrates the use of `@Sql` as a repeatable annotation using
Java 8. In this scenario the `test-schema.sql` script uses a different syntax for
single-line comments.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Test
	@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`"))
	@Sql("/test-user-data.sql")
	public void userTest {
		// execute code that uses the test schema and test data
	}
----

The following example is identical to the above except that the `@Sql` declarations are
grouped together within `@SqlGroup` for compatibility with Java 6 and Java 7.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Test
	@SqlGroup({
		@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
		@Sql("/test-user-data.sql")
	)}
	public void userTest {
		// execute code that uses the test schema and test data
	}
----

*Script execution phases*

By default, SQL scripts will be executed _before_ the corresponding test method. However,
if a particular set of scripts needs to be executed _after_ the test method -- for
example, to clean up database state -- the `executionPhase` attribute in `@Sql` can be
used as seen in the following example. Note that `ISOLATED` and `AFTER_TEST_METHOD` are
statically imported from `Sql.TransactionMode` and `Sql.ExecutionPhase` respectively.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Test
	@Sql(
		scripts = "create-test-data.sql",
		config = @SqlConfig(transactionMode = ISOLATED)
	)
	@Sql(
		scripts = "delete-test-data.sql",
		config = @SqlConfig(transactionMode = ISOLATED),
		executionPhase = AFTER_TEST_METHOD
	)
	public void userTest {
		// execute code that needs the test data to be committed
		// to the database outside of the test's transaction
	}
----

*Script configuration with `@SqlConfig`*

Configuration for script parsing and error handling can be configured via the
`@SqlConfig` annotation. When declared as a class-level annotation on an integration test
class, `@SqlConfig` serves as _global_ configuration for all SQL scripts within the test
class hierarchy. When declared directly via the `config` attribute of the `@Sql`
annotation, `@SqlConfig` serves as _local_ configuration for the SQL scripts declared
within the enclosing `@Sql` annotation. Every attribute in `@SqlConfig` has an implicit
default value which is documented in the javadocs of the corresponding attribute. Due to
the rules defined for annotation attributes in the Java Language Specification, it is
unfortunately not possible to assign a value of `null` to an annotation attribute. Thus,
in order to support overrides of inherited global configuration, `@SqlConfig` attributes
have an explicit default value of either `""` for Strings or `DEFAULT` for Enums. This
approach allows local declarations of `@SqlConfig` to selectively override individual
attributes from global declarations of `@SqlConfig` by providing a value other than `""`
or `DEFAULT`. Global `@SqlConfig` attributes are inherited whenever local `@SqlConfig`
attributes do not supply an explicit value other than `""` or `DEFAULT`. Explicit _local_
configuration therefore overrides _global_ configuration.

The configuration options provided by `@Sql` and `@SqlConfig` are equivalent to those
supported by `ScriptUtils` and `ResourceDatabasePopulator` but are a superset of those
provided by the `<jdbc:initialize-database/>` XML namespace element. Consult the javadocs
of individual attributes in `@Sql` and `@SqlConfig` for details.

[[testcontext-executing-sql-declaratively-tx]]
*Transaction management for `@Sql`*

By default, the `SqlScriptsTestExecutionListener` will infer the desired transaction
semantics for scripts configured via `@Sql`. Specifically, SQL scripts will be executed
without a transaction, within an existing Spring-managed transaction -- for example, a
transaction managed by the `TransactionalTestExecutionListener` for a test annotated with
`@Transactional` -- or within an isolated transaction, depending on the configured value
of the `transactionMode` attribute in `@SqlConfig` and the presence of a
`PlatformTransactionManager` in the test's `ApplicationContext`. As a bare minimum
however, a `javax.sql.DataSource` must be present in the test's `ApplicationContext`.

If the algorithms used by `SqlScriptsTestExecutionListener` to detect a `DataSource` and
`PlatformTransactionManager` and infer the transaction semantics do not suit your needs,
you may specify explicit names via the `dataSource` and `transactionManager` attributes
of `@SqlConfig`. Furthermore, the transaction propagation behavior can be controlled via
the `transactionMode` attribute of `@SqlConfig` -- for example, if scripts should be
executed in an isolated transaction. Although a thorough discussion of all supported
options for transaction management with `@Sql` is beyond the scope of this reference
manual, the javadocs for `@SqlConfig` and `SqlScriptsTestExecutionListener` provide
detailed information, and the following example demonstrates a typical testing scenario
using JUnit and transactional tests with `@Sql`. Note that there is no need to clean up
the database after the `usersTest()` method is executed since any changes made to the
database (either within the the test method or within the `/test-data.sql` script) will
be automatically rolled back by the `TransactionalTestExecutionListener` (see
<<testcontext-tx,transaction management>> for details).

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	@ContextConfiguration(classes = TestDatabaseConfig.class)
	@Transactional
	public class TransactionalSqlScriptsTests {

		protected JdbcTemplate jdbcTemplate;

		@Autowired
		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		@Test
		@Sql("/test-data.sql")
		public void usersTest() {
			// verify state in test database:
			assertNumUsers(2);
			// execute code that uses the test data...
		}

		protected int countRowsInTable(String tableName) {
			return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
		}

		protected void assertNumUsers(int expected) {
			assertEquals("Number of rows in the ''user'' table.", expected, countRowsInTable("user"));
		}
	}
----


[[testcontext-support-classes]]
===== TestContext Framework support classes

[[testcontext-support-classes-junit4]]
====== JUnit support classes
The `org.springframework.test.context.junit4` package provides the following support
classes for JUnit-based test cases.

* `AbstractJUnit4SpringContextTests`
* `AbstractTransactionalJUnit4SpringContextTests`

`AbstractJUnit4SpringContextTests` is an abstract base test class that integrates the
__Spring TestContext Framework__ with explicit `ApplicationContext` testing support in
a JUnit 4.9+ environment. When you extend `AbstractJUnit4SpringContextTests`, you can
access a `protected` `applicationContext` instance variable that can be used to perform
explicit bean lookups or to test the state of the context as a whole.

`AbstractTransactionalJUnit4SpringContextTests` is an abstract __transactional__ extension
of `AbstractJUnit4SpringContextTests` that adds some convenience functionality for JDBC
access. This class expects a `javax.sql.DataSource` bean and a `PlatformTransactionManager`
bean to be defined in the `ApplicationContext`. When you extend
`AbstractTransactionalJUnit4SpringContextTests` you can access a `protected` `jdbcTemplate`
instance variable that can be used to execute SQL statements to query the database. Such
queries can be used to confirm database state both __prior to__ and __after__ execution of
database-related application code, and Spring ensures that such queries run in the scope of
the same transaction as the application code. When used in conjunction with an ORM tool,
be sure to avoid <<testcontext-tx-false-positives,false positives>>. As mentioned in
<<integration-testing-support-jdbc>>, `AbstractTransactionalJUnit4SpringContextTests`
also provides convenience methods which delegate to methods in `JdbcTestUtils` using the
aforementioned `jdbcTemplate`. Furthermore, `AbstractTransactionalJUnit4SpringContextTests`
provides an `executeSqlScript(..)` method for executing SQL scripts against the configured
`DataSource`.

[TIP]
====
These classes are a convenience for extension. If you do not want your test classes to be
tied to a Spring-specific class hierarchy, you can configure your own custom test classes
by using `@RunWith(SpringJUnit4ClassRunner.class)`, `@ContextConfiguration`,
`@TestExecutionListeners`, and so on.
====

[[testcontext-junit4-runner]]
====== Spring JUnit Runner
The __Spring TestContext Framework__ offers full integration with JUnit 4.9+ through a
custom runner (tested on JUnit 4.9 -- 4.11). By annotating test classes with
`@RunWith(SpringJUnit4ClassRunner.class)`, developers can implement standard JUnit-based
unit and integration tests and simultaneously reap the benefits of the TestContext
framework such as support for loading application contexts, dependency injection of test
instances, transactional test method execution, and so on. The following code listing
displays the minimal requirements for configuring a test class to run with the custom
Spring Runner. `@TestExecutionListeners` is configured with an empty list in order to
disable the default listeners, which otherwise would require an ApplicationContext to be
configured through `@ContextConfiguration`.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@RunWith(SpringJUnit4ClassRunner.class)
	@TestExecutionListeners({})
	public class SimpleTest {

		@Test
		public void testMethod() {
			// execute test logic...
		}
	}
----

[[testcontext-support-classes-testng]]
====== TestNG support classes
The `org.springframework.test.context.testng` package provides the following support
classes for TestNG based test cases.

* `AbstractTestNGSpringContextTests`
* `AbstractTransactionalTestNGSpringContextTests`

`AbstractTestNGSpringContextTests` is an abstract base test class that integrates the
__Spring TestContext Framework__ with explicit `ApplicationContext` testing support in
a TestNG environment. When you extend `AbstractTestNGSpringContextTests`, you can
access a `protected` `applicationContext` instance variable that can be used to perform
explicit bean lookups or to test the state of the context as a whole.

`AbstractTransactionalTestNGSpringContextTests` is an abstract __transactional__ extension
of `AbstractTestNGSpringContextTests` that adds some convenience functionality for JDBC
access. This class expects a `javax.sql.DataSource` bean and a `PlatformTransactionManager`
bean to be defined in the `ApplicationContext`. When you extend
`AbstractTransactionalTestNGSpringContextTests` you can access a `protected` `jdbcTemplate`
instance variable that can be used to execute SQL statements to query the database. Such
queries can be used to confirm database state both __prior to__ and __after__ execution of
database-related application code, and Spring ensures that such queries run in the scope of
the same transaction as the application code. When used in conjunction with an ORM tool,
be sure to avoid <<testcontext-tx-false-positives,false positives>>. As mentioned in
<<integration-testing-support-jdbc>>, `AbstractTransactionalTestNGSpringContextTests`
also provides convenience methods which delegate to methods in `JdbcTestUtils` using the
aforementioned `jdbcTemplate`. Furthermore, `AbstractTransactionalTestNGSpringContextTests`
provides an `executeSqlScript(..)` method for executing SQL scripts against the configured
`DataSource`.


[TIP]
====
These classes are a convenience for extension. If you do not want your test classes to be
tied to a Spring-specific class hierarchy, you can configure your own custom test classes
by using `@ContextConfiguration`, `@TestExecutionListeners`, and so on, and by manually
instrumenting your test class with a `TestContextManager`. See the source code of
`AbstractTestNGSpringContextTests` for an example of how to instrument your test class.
====

