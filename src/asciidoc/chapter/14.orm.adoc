[[orm]]
== 对象关系映射(ORM)数据访问




[[orm-introduction]]
=== 介绍 Spring 中的 ORM 
Spring Framework 支持集成  Hibernate, Java Persistence API (JPA) 和 Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现,和事务策略。例如,对于 Hibernate 有一流的支持，使用方便的 IoC 特性,解决许多典型的 Hibernate 集成问题。您可以通过依赖注入配置的所有  O/R (对象关系) 映射工具的特性。他们可以参与 Spring 的资源和事务管理,他们符合 Spring 的通用事务和 DAO 异常层次结构。建议集成风格是在 Hibernate, JPA, 和 JDO APIs 中使用 DAO 。旧的 Spring DAO 模板不再推荐使用;然而,关于风格的论述可以见
<<classic-spring-orm>> .

当你创建数据访问应用时，Spring 能对你选择的 ORM 层进行显着的增强。你根据你的需求进行尽可能多的集成支持，同时需要比这种整合在建一个类似的基础设施时的内部风险。通过库，你可以使用很多的 ORM 的支持，不用管技术，因为一切都是设计成一组可重用的 JavaBean。ORM 在 Spring IoC 容器便于配置和部署。因此，本文中的大多数示例配置显示在 Spring 容器里。

使用 Spring Framework 来创建您的 ORM DAO 好处包括:

* __更容易测试.__ Spring 的 IoC 方法便于交换实现和配置 Hibernate `SessionFactory` 实例,JDBC `DataSource`(数据源)实例,事务管理,以及映射对象实现(如果需要)。这反过来使其更容易隔离测试每一块持续相关代码。
* __常见的数据访问异常.__ Spring 可以从你的 ORM 工具包装异常,将他们从专有的(可能检查)异常转为共同运行时 DataAccessException 层次。这个特性允许您处理大多数持久化的异常不可恢复的，而且只出现在适当的层,没有恼人的捕捉、抛出、和异常声明。当然根据需要你仍然可以捕获和处理异常。记住,JDBC 异常(包括数据库特殊的方言)也转换为相同的层次结构,这意味着您可以在使用 JDBC 执行一些操作时拥有一致的编程模型。
* __通用资源管理.__ Spring 应用程序上下文可以处理的定位和配置Hibernate `SessionFactory` 实例,JPA `EntityManagerFactory`实例,JDBC `DataSource`(数据源)实例,和其他相关资源。这使得这些值易于管理和改变。Spring 提供了高效、简单和安全处理持久性的资源。例如,关联代码来使用 Hibernate ，通常需要使用相同的 Hibernate `Session`,以确保高效和适当的事务处理。Spring 很容易创建和透明地将`Session`绑定到当前线程,通过使用 Hibernate `SessionFactory` 来暴露出当前`Session`。因此，针对任何本地或 JTA 事务环境，Spring 解决许多在典型的 Hibernate 使用中的惯性问题。
* __集成事务管理.__ 可以通过声明式的,面向方面的编程(AOP)风格方法拦截器包装你的 ORM 代码通过吗，可以采用`@Transactional`注释或通过显式配置事务 AOP advice 在一个 XML 配置文件中。在这两种情况下,都是可以为您处理事务语义和异常处理(回滚,等等)。如下面所讨论的
  <<orm-resource-mngmnt,Resource and transaction management>>, 你也可以交换不同的事务管理器,而不影响 ORM 相关的代码。例如,您可以在相同的全面服务(如声明性事务)的两个场景，实现本地事务和 JTA 之间交换。另外,JDBC 相关的代码可以完全集成事务到你使用的 ORM 代码中。这是对于数据访问有用,但不适合 ORM 中的批处理和 BLOB 流等,这仍然需要在ORM操作 交换共同的事务。

[TIP]
====
为更全面了解的 ORM 的支持,包括支持替代数据库技术,如 MongoDB 数据库,您可能希望查看
http://projects.spring.io/spring-data/[Spring Data] 配套的项目。如果你是一个 JPA 用户 https://spring.io/guides/gs/accessing-data-jpa/[Getting Started Accessing
Data with JPA] 提供了一个很好的介绍.
====



[[orm-general]]
=== 常见的 ORM 集成方面的注意事项
本节强调的 注意事项应用与所有的 ORM 技术。 
<<orm-hibernate>> 这节提供了更多细节，同时展示了这些特性和具体上下文的配置。

Spring 的 ORM 集成的主要目标是明确的应用程序分层,包括在任何数据访问、事务技术和松耦合的应用程序对象。没有更多的业务服务依赖于数据访问或事务策略,不再资源查找硬编码,不再强制替换单例,没有更多的自定义服务注册。一个简单的和一致的方法来连接应用程序对象,让他们尽可能的对容器依赖是可以重用并且是自由。所有个人数据访问特性可用的,但可以与Spring 应用程序上下文的概念集成,提供基于 xml 的配置和交叉引用的普通 JavaBean 实例而不需要 Spring-aware（Spring 的意识）。在一个典型的 Spring 应用程序中,许多重要的对象是 JavaBean:数据访问模板,数据访问对象,事务管理器,使用数据访问对象和事务管理器的业务服务, web 视图解析器,使用业务服务的 web 控制器,等等。



[[orm-resource-mngmnt]]
==== 资源和事务管理
典型的商业应用是用重复的资源管理代码杂乱的堆积起来的。很多项目试图创造自己的解决方案，有时为了编程方便来牺牲故障的处理。Spring 提倡简单的处理适当资源的方案，即在JDBC的案例 IoC 通过模板和在 ORM 技术应用 AOP 拦截器。

基础设施提供适当的资源处理，并且能将特定的 API 异常适当的转换为一个未检查的基础的异常层次结构。Spring  引入了 DAO 异常层次结构，适用于任何的数据访问策略。对于直接的 JDBC，在前一节提到的`JdbcTemplate`类提供了连接处理和将 `SQLException` 适当的转换为`DataAccessException` 层次结构，其中包括将 具体数据库 SQL 错误代码转为有意义的异常类。对于 ORM 技术，见下一节，如何得到相同异常转换的好处。

当涉及到事务管理，`JdbcTemplate`类与 Spring 的事务支持挂钩，并且通过各自的 Spring 事务管理器支持 JTA 和 JDBC 事务。为支持 ORM 技术 Spring 提供了通过与 JTA 支持类似的 Hibernate，JPA，和 JDO 事务管理器来实现对 Hibernate，JPA 和 JDO 支持。更多事务的支持，详细信息，参 <<transaction>> chapter.



[[orm-exception-translation]]
==== 异常转化
当你在 DAO 中使用 Hibernate、JPA 或 JDO 时,你必须决定如何处理持久化技术的原生异常类。运用不同的技术，DAO 会抛出`HibernateException`、`PersistenceException`或`JDOException` 的子类。这些异常都是运行时的异常,不需要声明或捕获。你可能必须处理`IllegalArgumentException` 和`IllegalStateException`。这意味着调用者只能将异常处理成为一个通常为致命的问题,除非他们想要依赖于持久化技术自身的异常结构。捕捉乐观锁定失败等具体原因是不可能的除非把调用者与实现策略相联系。取消这交换是可接受的对于应用程序是基于 ORM 和/或 不需要任何特殊的异常处理。然而,Spring 通过 `@Repository` 注解 来使异常透明的转化:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Repository
	public class ProductDaoImpl implements ProductDao {

		// class body here...

	}
----

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<!-- Exception translation bean post processor -->
		<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>

		<bean id="myProductDao" class="product.ProductDaoImpl"/>

	</beans>
----

postprocessor 会自动寻找所有异常转换器( 实现 `PersistenceExceptionTranslator` 接口),建议所有 bean 标有`@Repository`注解,以便发现的转换器可以在抛出异常时拦截和应用适当的转换。

总之:您可以实现 DAO  基于纯持久化技术的API和注解,同时仍然受益于Spring 管理事务,依赖注入、和透明将异常转换(如果需要)为 Spring 的自定义的异常层次结构。



[[orm-hibernate]]
=== Hibernate
We will start with a coverage of http://www.hibernate.org/[Hibernate 3] in a Spring
environment, using it to demonstrate the approach that Spring takes towards integrating
O/R mappers. This section will cover many issues in detail and show different variations
of DAO implementations and transaction demarcation. Most of these patterns can be
directly translated to all other supported ORM tools. The following sections in this
chapter will then cover the other ORM technologies, showing briefer examples there.

[NOTE]
====
As of Spring 4.0, Spring requires Hibernate 3.6 or later.
====



[[orm-session-factory-setup]]
==== SessionFactory setup in a Spring container

To avoid tying application objects to hard-coded resource lookups, you can define
resources such as a JDBC `DataSource` or a Hibernate `SessionFactory` as beans in the
Spring container. Application objects that need to access resources receive references
to such predefined instances through bean references, as illustrated in the DAO
definition in the next section.

The following excerpt from an XML application context definition shows how to set up a
JDBC `DataSource` and a Hibernate `SessionFactory` on top of it:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			<property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
			<property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
			<property name="username" value="sa"/>
			<property name="password" value=""/>
		</bean>

		<bean id="mySessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
			<property name="dataSource" ref="myDataSource"/>
			<property name="mappingResources">
				<list>
					<value>product.hbm.xml</value>
				</list>
			</property>
			<property name="hibernateProperties">
				<value>
					hibernate.dialect=org.hibernate.dialect.HSQLDialect
				</value>
			</property>
		</bean>

	</beans>
----

Switching from a local Jakarta Commons DBCP `BasicDataSource` to a JNDI-located
`DataSource` (usually managed by an application server) is just a matter of
configuration:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>
		<jee:jndi-lookup id="myDataSource" jndi-name="java:comp/env/jdbc/myds"/>
	</beans>
----

You can also access a JNDI-located `SessionFactory`, using Spring's
`JndiObjectFactoryBean` / `<jee:jndi-lookup>` to retrieve and expose it. However, that
is typically not common outside of an EJB context.



[[orm-hibernate-straight]]
==== Implementing DAOs based on plain Hibernate 3 API
Hibernate 3 has a feature called contextual sessions, wherein Hibernate itself manages
one current `Session` per transaction. This is roughly equivalent to Spring's
synchronization of one Hibernate `Session` per transaction. A corresponding DAO
implementation resembles the following example, based on the plain Hibernate API:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class ProductDaoImpl implements ProductDao {

		private SessionFactory sessionFactory;

		public void setSessionFactory(SessionFactory sessionFactory) {
			this.sessionFactory = sessionFactory;
		}

		public Collection loadProductsByCategory(String category) {
			return this.sessionFactory.getCurrentSession()
					.createQuery("from test.Product product where product.category=?")
					.setParameter(0, category)
					.list();
		}
	}
----

This style is similar to that of the Hibernate reference documentation and examples,
except for holding the `SessionFactory` in an instance variable. We strongly recommend
such an instance-based setup over the old-school `static` `HibernateUtil` class from
Hibernate's CaveatEmptor sample application. (In general, do not keep any resources in
`static` variables unless __absolutely__ necessary.)

The above DAO follows the dependency injection pattern: it fits nicely into a Spring IoC
container, just as it would if coded against Spring's `HibernateTemplate`. Of course,
such a DAO can also be set up in plain Java (for example, in unit tests). Simply
instantiate it and call `setSessionFactory(..)` with the desired factory reference. As a
Spring bean definition, the DAO would resemble the following:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="myProductDao" class="product.ProductDaoImpl">
			<property name="sessionFactory" ref="mySessionFactory"/>
		</bean>

	</beans>
----

The main advantage of this DAO style is that it depends on Hibernate API only; no import
of any Spring class is required. This is of course appealing from a non-invasiveness
perspective, and will no doubt feel more natural to Hibernate developers.

However, the DAO throws plain `HibernateException` (which is unchecked, so does not have
to be declared or caught), which means that callers can only treat exceptions as
generally fatal - unless they want to depend on Hibernate's own exception hierarchy.
Catching specific causes such as an optimistic locking failure is not possible without
tying the caller to the implementation strategy. This trade off might be acceptable to
applications that are strongly Hibernate-based and/or do not need any special exception
treatment.

Fortunately, Spring's `LocalSessionFactoryBean` supports Hibernate's
`SessionFactory.getCurrentSession()` method for any Spring transaction strategy,
returning the current Spring-managed transactional `Session` even with
`HibernateTransactionManager`. Of course, the standard behavior of that method remains
the return of the current `Session` associated with the ongoing JTA transaction, if any.
This behavior applies regardless of whether you are using Spring's
`JtaTransactionManager`, EJB container managed transactions (CMTs), or JTA.

In summary: you can implement DAOs based on the plain Hibernate 3 API, while still being
able to participate in Spring-managed transactions.



[[orm-hibernate-tx-declarative]]
==== Declarative transaction demarcation
We recommend that you use Spring's declarative transaction support, which enables you to
replace explicit transaction demarcation API calls in your Java code with an AOP
transaction interceptor. This transaction interceptor can be configured in a Spring
container using either Java annotations or XML.This declarative transaction capability
allows you to keep business services free of repetitive transaction demarcation code and
to focus on adding business logic, which is the real value of your application.

[NOTE]
====
Prior to continuing, you are __strongly__ encouraged to read <<transaction-declarative>>
if you have not done so.
====

Furthermore, transaction semantics like propagation behavior and isolation level can be
changed in a configuration file and do not affect the business service implementations.

The following example shows how you can configure an AOP transaction interceptor, using
XML, for a simple service class:

[source,xml,indent=0]
[subs="verbatim"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			http://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			http://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- SessionFactory, DataSource, etc. omitted -->

		<bean id="transactionManager"
				class="org.springframework.orm.hibernate3.HibernateTransactionManager">
			<property name="sessionFactory" ref="sessionFactory"/>
		</bean>

		<aop:config>
			<aop:pointcut id="productServiceMethods"
					expression="execution(* product.ProductService.*(..))"/>
			<aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/>
		</aop:config>

		<tx:advice id="txAdvice" transaction-manager="myTxManager">
			<tx:attributes>
				<tx:method name="increasePrice*" propagation="REQUIRED"/>
				<tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/>
				<tx:method name="*" propagation="SUPPORTS" read-only="true"/>
			</tx:attributes>
		</tx:advice>

		<bean id="myProductService" class="product.SimpleProductService">
			<property name="productDao" ref="myProductDao"/>
		</bean>

	</beans>
----

This is the service class that is advised:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class ProductServiceImpl implements ProductService {

		private ProductDao productDao;

		public void setProductDao(ProductDao productDao) {
			this.productDao = productDao;
		}

		// notice the absence of transaction demarcation code in this method
		// Spring's declarative transaction infrastructure will be demarcating
		// transactions on your behalf
		public void increasePriceOfAllProductsInCategory(final String category) {
			List productsToChange = this.productDao.loadProductsByCategory(category);
			// ...
		}
	}
----

We also show an attribute-support based configuration, in the following example. You
annotate the service layer with @Transactional annotations and instruct the Spring
container to find these annotations and provide transactional semantics for these
annotated methods.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class ProductServiceImpl implements ProductService {

		private ProductDao productDao;

		public void setProductDao(ProductDao productDao) {
			this.productDao = productDao;
		}

		@Transactional
		public void increasePriceOfAllProductsInCategory(final String category) {
			List productsToChange = this.productDao.loadProductsByCategory(category);
			// ...
		}

		@Transactional(readOnly = true)
		public List<Product> findAllProducts() {
			return this.productDao.findAllProducts();
		}

	}
----

As you can see from the following configuration example, the configuration is much
simplified, compared to the XML example above, while still providing the same
functionality driven by the annotations in the service layer code. All you need to
provide is the TransactionManager implementation and a "<tx:annotation-driven/>" entry.

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			http://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			http://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- SessionFactory, DataSource, etc. omitted -->

		<bean id="transactionManager"
				class="org.springframework.orm.hibernate3.HibernateTransactionManager">
			<property name="sessionFactory" ref="sessionFactory"/>
		</bean>

		<tx:annotation-driven/>

		<bean id="myProductService" class="product.SimpleProductService">
			<property name="productDao" ref="myProductDao"/>
		</bean>

	</beans>
----



[[orm-hibernate-tx-programmatic]]
==== Programmatic transaction demarcation
You can demarcate transactions in a higher level of the application, on top of such
lower-level data access services spanning any number of operations. Nor do restrictions
exist on the implementation of the surrounding business service; it just needs a Spring
`PlatformTransactionManager`. Again, the latter can come from anywhere, but preferably
as a bean reference through a `setTransactionManager(..)` method, just as the
`productDAO` should be set by a `setProductDao(..)` method. The following snippets show
a transaction manager and a business service definition in a Spring application context,
and an example for a business method implementation:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">
			<property name="sessionFactory" ref="mySessionFactory"/>
		</bean>

		<bean id="myProductService" class="product.ProductServiceImpl">
			<property name="transactionManager" ref="myTxManager"/>
			<property name="productDao" ref="myProductDao"/>
		</bean>

	</beans>
----

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class ProductServiceImpl implements ProductService {

		private TransactionTemplate transactionTemplate;
		private ProductDao productDao;

		public void setTransactionManager(PlatformTransactionManager transactionManager) {
			this.transactionTemplate = new TransactionTemplate(transactionManager);
		}

		public void setProductDao(ProductDao productDao) {
			this.productDao = productDao;
		}

		public void increasePriceOfAllProductsInCategory(final String category) {
			this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {
				public void doInTransactionWithoutResult(TransactionStatus status) {
					List productsToChange = this.productDao.loadProductsByCategory(category);
					// do the price increase...
				}
			});
		}
	}
----

Spring's `TransactionInterceptor` allows any checked application exception to be thrown
with the callback code, while `TransactionTemplate` is restricted to unchecked
exceptions within the callback. `TransactionTemplate` triggers a rollback in case of an
unchecked application exception, or if the transaction is marked rollback-only by the
application (via `TransactionStatus`). `TransactionInterceptor` behaves the same way by
default but allows configurable rollback policies per method.



[[orm-hibernate-tx-strategies]]
==== Transaction management strategies
Both `TransactionTemplate` and `TransactionInterceptor` delegate the actual transaction
handling to a `PlatformTransactionManager` instance, which can be a
`HibernateTransactionManager` (for a single Hibernate `SessionFactory`, using a
`ThreadLocal` `Session` under the hood) or a `JtaTransactionManager` (delegating to the
JTA subsystem of the container) for Hibernate applications. You can even use a custom
`PlatformTransactionManager` implementation. Switching from native Hibernate transaction
management to JTA, such as when facing distributed transaction requirements for certain
deployments of your application, is just a matter of configuration. Simply replace
the Hibernate transaction manager with Spring's JTA transaction implementation. Both
transaction demarcation and data access code will work without changes, because they
just use the generic transaction management APIs.

For distributed transactions across multiple Hibernate session factories, simply combine
`JtaTransactionManager` as a transaction strategy with multiple
`LocalSessionFactoryBean` definitions. Each DAO then gets one specific `SessionFactory`
reference passed into its corresponding bean property. If all underlying JDBC data
sources are transactional container ones, a business service can demarcate transactions
across any number of DAOs and any number of session factories without special regard, as
long as it is using `JtaTransactionManager` as the strategy.

[source,xml,indent=0]
[subs="verbatim"]
----
	<beans>

		<jee:jndi-lookup id="dataSource1" jndi-name="java:comp/env/jdbc/myds1"/>

		<jee:jndi-lookup id="dataSource2" jndi-name="java:comp/env/jdbc/myds2"/>

		<bean id="mySessionFactory1"
				class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
			<property name="dataSource" ref="myDataSource1"/>
			<property name="mappingResources">
				<list>
					<value>product.hbm.xml</value>
				</list>
			</property>
			<property name="hibernateProperties">
				<value>
					hibernate.dialect=org.hibernate.dialect.MySQLDialect
					hibernate.show_sql=true
				</value>
			</property>
		</bean>

		<bean id="mySessionFactory2"
				class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
			<property name="dataSource" ref="myDataSource2"/>
			<property name="mappingResources">
				<list>
					<value>inventory.hbm.xml</value>
				</list>
			</property>
			<property name="hibernateProperties">
				<value>
					hibernate.dialect=org.hibernate.dialect.OracleDialect
				</value>
			</property>
		</bean>

		<bean id="myTxManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>

		<bean id="myProductDao" class="product.ProductDaoImpl">
			<property name="sessionFactory" ref="mySessionFactory1"/>
		</bean>

		<bean id="myInventoryDao" class="product.InventoryDaoImpl">
			<property name="sessionFactory" ref="mySessionFactory2"/>
		</bean>

		<bean id="myProductService" class="product.ProductServiceImpl">
			<property name="productDao" ref="myProductDao"/>
			<property name="inventoryDao" ref="myInventoryDao"/>
		</bean>

		<aop:config>
			<aop:pointcut id="productServiceMethods"
					expression="execution(* product.ProductService.*(..))"/>
			<aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/>
		</aop:config>

		<tx:advice id="txAdvice" transaction-manager="myTxManager">
			<tx:attributes>
				<tx:method name="increasePrice*" propagation="REQUIRED"/>
				<tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/>
				<tx:method name="*" propagation="SUPPORTS" read-only="true"/>
			</tx:attributes>
		</tx:advice>

	</beans>
----

Both `HibernateTransactionManager` and `JtaTransactionManager` allow for proper
JVM-level cache handling with Hibernate, without container-specific transaction manager
lookup or a JCA connector (if you are not using EJB to initiate transactions).

`HibernateTransactionManager` can export the Hibernate JDBC `Connection` to plain JDBC
access code, for a specific `DataSource`. This capability allows for high-level
transaction demarcation with mixed Hibernate and JDBC data access completely without
JTA, if you are accessing only one database. `HibernateTransactionManager` automatically
exposes the Hibernate transaction as a JDBC transaction if you have set up the passed-in
`SessionFactory` with a `DataSource` through the `dataSource` property of the
`LocalSessionFactoryBean` class. Alternatively, you can specify explicitly the
`DataSource` for which the transactions are supposed to be exposed through the
`dataSource` property of the `HibernateTransactionManager` class.



[[orm-hibernate-resources]]
==== Comparing container-managed and locally defined resources
You can switch between a container-managed JNDI `SessionFactory` and a locally defined
one, without having to change a single line of application code. Whether to keep
resource definitions in the container or locally within the application is mainly a
matter of the transaction strategy that you use. Compared to a Spring-defined local
`SessionFactory`, a manually registered JNDI `SessionFactory` does not provide any
benefits. Deploying a `SessionFactory` through Hibernate's JCA connector provides the
added value of participating in the Java EE server's management infrastructure, but does
not add actual value beyond that.

Spring's transaction support is not bound to a container. Configured with any strategy
other than JTA, transaction support also works in a stand-alone or test environment.
Especially in the typical case of single-database transactions, Spring's single-resource
local transaction support is a lightweight and powerful alternative to JTA. When you use
local EJB stateless session beans to drive transactions, you depend both on an EJB
container and JTA, even if you access only a single database, and only use stateless
session beans to provide declarative transactions through container-managed
transactions. Also, direct use of JTA programmatically requires a Java EE environment as
well. JTA does not involve only container dependencies in terms of JTA itself and of
JNDI `DataSource` instances. For non-Spring, JTA-driven Hibernate transactions, you have
to use the Hibernate JCA connector, or extra Hibernate transaction code with the
`TransactionManagerLookup` configured for proper JVM-level caching.

Spring-driven transactions can work as well with a locally defined Hibernate
`SessionFactory` as they do with a local JDBC `DataSource` if they are accessing a
single database. Thus you only have to use Spring's JTA transaction strategy when you
have distributed transaction requirements. A JCA connector requires container-specific
deployment steps, and obviously JCA support in the first place. This configuration
requires more work than deploying a simple web application with local resource
definitions and Spring-driven transactions. Also, you often need the Enterprise Edition
of your container if you are using, for example, WebLogic Express, which does not
provide JCA. A Spring application with local resources and transactions spanning one
single database works in any Java EE web container (without JTA, JCA, or EJB) such as
Tomcat, Resin, or even plain Jetty. Additionally, you can easily reuse such a middle
tier in desktop applications or test suites.

All things considered, if you do not use EJBs, stick with local `SessionFactory` setup
and Spring's `HibernateTransactionManager` or `JtaTransactionManager`. You get all of
the benefits, including proper transactional JVM-level caching and distributed
transactions, without the inconvenience of container deployment. JNDI registration of a
Hibernate `SessionFactory` through the JCA connector only adds value when used in
conjunction with EJBs.



[[orm-hibernate-invalid-jdbc-access-error]]
==== Spurious application server warnings with Hibernate
In some JTA environments with very strict `XADataSource` implementations -- currently
only some WebLogic Server and WebSphere versions -- when Hibernate is configured without
regard to the JTA `PlatformTransactionManager` object for that environment, it is
possible for spurious warning or exceptions to show up in the application server log.
These warnings or exceptions indicate that the connection being accessed is no longer
valid, or JDBC access is no longer valid, possibly because the transaction is no longer
active. As an example, here is an actual exception from WebLogic:

[literal]
[subs="verbatim,quotes"]
----
java.sql.SQLException: The transaction is no longer active - status: 'Committed'. No
further JDBC access is allowed within this transaction.
----

You resolve this warning by simply making Hibernate aware of the JTA
`PlatformTransactionManager` instance, to which it will synchronize (along with Spring).
You have two options for doing this:

* If in your application context you are already directly obtaining the JTA
  `PlatformTransactionManager` object (presumably from JNDI through
  `JndiObjectFactoryBean` or `<jee:jndi-lookup>`) and feeding it, for example, to
  Spring's `JtaTransactionManager`, then the easiest way is to specify a reference to
  the bean defining this JTA `PlatformTransactionManager` instance as the value of the
  `jtaTransactionManager` property for `LocalSessionFactoryBean.` Spring then makes the
  object available to Hibernate.
* More likely you do not already have the JTA `PlatformTransactionManager` instance,
  because Spring's `JtaTransactionManager` can find it itself. Thus you need to
  configure Hibernate to look up JTA `PlatformTransactionManager` directly. You do this
  by configuring an application server- specific `TransactionManagerLookup` class in the
  Hibernate configuration, as described in the Hibernate manual.

The remainder of this section describes the sequence of events that occur with and
without Hibernate's awareness of the JTA `PlatformTransactionManager`.

When Hibernate is not configured with any awareness of the JTA
`PlatformTransactionManager`, the following events occur when a JTA transaction commits:

* The JTA transaction commits.
* Spring's `JtaTransactionManager` is synchronized to the JTA transaction, so it is
  called back through an __afterCompletion__ callback by the JTA transaction manager.
* Among other activities, this synchronization can trigger a callback by Spring to
  Hibernate, through Hibernate's `afterTransactionCompletion` callback (used to clear
  the Hibernate cache), followed by an explicit `close()` call on the Hibernate Session,
  which causes Hibernate to attempt to `close()` the JDBC Connection.
* In some environments, this `Connection.close()` call then triggers the warning or
  error, as the application server no longer considers the `Connection` usable at all,
  because the transaction has already been committed.

When Hibernate is configured with awareness of the JTA `PlatformTransactionManager`, the
following events occur when a JTA transaction commits:

* the JTA transaction is ready to commit.
* Spring's `JtaTransactionManager` is synchronized to the JTA transaction, so the
  transaction is called back through a __beforeCompletion__ callback by the JTA
  transaction manager.
* Spring is aware that Hibernate itself is synchronized to the JTA transaction, and
  behaves differently than in the previous scenario. Assuming the Hibernate `Session`
  needs to be closed at all, Spring will close it now.
* The JTA transaction commits.
* Hibernate is synchronized to the JTA transaction, so the transaction is called back
  through an __afterCompletion__ callback by the JTA transaction manager, and can
  properly clear its cache.




[[orm-jdo]]
=== JDO
Spring supports the standard JDO 2.0 and 2.1 APIs as data access strategy, following the
same style as the Hibernate support. The corresponding integration classes reside in the
`org.springframework.orm.jdo` package.



[[orm-jdo-setup]]
==== PersistenceManagerFactory setup

Spring provides a `LocalPersistenceManagerFactoryBean` class that allows you to define a
local JDO `PersistenceManagerFactory` within a Spring application context:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="myPmf" class="org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean">
			<property name="configLocation" value="classpath:kodo.properties"/>
		</bean>

	</beans>
----

Alternatively, you can set up a `PersistenceManagerFactory` through direct instantiation
of a `PersistenceManagerFactory` implementation class. A JDO `PersistenceManagerFactory`
implementation class follows the JavaBeans pattern, just like a JDBC `DataSource`
implementation class, which is a natural fit for a configuration that uses Spring. This
setup style usually supports a Spring-defined JDBC `DataSource`, passed into the
`connectionFactory` property. For example, for the open source JDO implementation
DataNucleus (formerly JPOX) ( http://www.datanucleus.org/[http://www.datanucleus.org/]),
this is the XML configuration of the `PersistenceManagerFactory` implementation:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

	 <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driverClassName}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	 </bean>

	 <bean id="myPmf" class="org.datanucleus.jdo.JDOPersistenceManagerFactory" destroy-method="close">
		<property name="connectionFactory" ref="dataSource"/>
		<property name="nontransactionalRead" value="true"/>
	 </bean>

	</beans>
----

You can also set up JDO `PersistenceManagerFactory` in the JNDI environment of a Java EE
application server, usually through the JCA connector provided by the particular JDO
implementation. Spring's standard `JndiObjectFactoryBean` or `<jee:jndi-lookup>` can be
used to retrieve and expose such a `PersistenceManagerFactory`. However, outside an EJB
context, no real benefit exists in holding the `PersistenceManagerFactory` in JNDI: only
choose such a setup for a good reason. See <<orm-hibernate-resources>> for a discussion;
the arguments there apply to JDO as well.



[[orm-jdo-daos-straight]]
==== Implementing DAOs based on the plain JDO API
DAOs can also be written directly against plain JDO API, without any Spring
dependencies, by using an injected `PersistenceManagerFactory`. The following is an
example of a corresponding DAO implementation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class ProductDaoImpl implements ProductDao {

		private PersistenceManagerFactory persistenceManagerFactory;

		public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
			this.persistenceManagerFactory = pmf;
		}

		public Collection loadProductsByCategory(String category) {
			PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
			try {
				Query query = pm.newQuery(Product.class, "category = pCategory");
				query.declareParameters("String pCategory");
				return query.execute(category);
			}
			finally {
				pm.close();
			}
		}
	}
----

Because the above DAO follows the dependency injection pattern, it fits nicely into a
Spring container, just as it would if coded against Spring's `JdoTemplate`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="myProductDao" class="product.ProductDaoImpl">
			<property name="persistenceManagerFactory" ref="myPmf"/>
		</bean>

	</beans>
----

The main problem with such DAOs is that they always get a new `PersistenceManager` from
the factory. To access a Spring-managed transactional `PersistenceManager`, define a
`TransactionAwarePersistenceManagerFactoryProxy` (as included in Spring) in front of
your target `PersistenceManagerFactory`, then passing a reference to that proxy into
your DAOs as in the following example:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="myPmfProxy"
				class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy">
			<property name="targetPersistenceManagerFactory" ref="myPmf"/>
		</bean>

		<bean id="myProductDao" class="product.ProductDaoImpl">
			<property name="persistenceManagerFactory" ref="myPmfProxy"/>
		</bean>

	</beans>
----

Your data access code will receive a transactional `PersistenceManager` (if any) from
the `PersistenceManagerFactory.getPersistenceManager()` method that it calls. The latter
method call goes through the proxy, which first checks for a current transactional
`PersistenceManager` before getting a new one from the factory. Any `close()` calls on
the `PersistenceManager` are ignored in case of a transactional `PersistenceManager`.

If your data access code always runs within an active transaction (or at least within
active transaction synchronization), it is safe to omit the `PersistenceManager.close()`
call and thus the entire `finally` block, which you might do to keep your DAO
implementations concise:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class ProductDaoImpl implements ProductDao {

		private PersistenceManagerFactory persistenceManagerFactory;

		public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
			this.persistenceManagerFactory = pmf;
		}

		public Collection loadProductsByCategory(String category) {
			PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
			Query query = pm.newQuery(Product.class, "category = pCategory");
			query.declareParameters("String pCategory");
			return query.execute(category);
		}
	}
----

With such DAOs that rely on active transactions, it is recommended that you enforce
active transactions through turning off
`TransactionAwarePersistenceManagerFactoryProxy`'s `allowCreate` flag:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="myPmfProxy"
				class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy">
			<property name="targetPersistenceManagerFactory" ref="myPmf"/>
			<property name="allowCreate" value="false"/>
		</bean>

		<bean id="myProductDao" class="product.ProductDaoImpl">
			<property name="persistenceManagerFactory" ref="myPmfProxy"/>
		</bean>

	</beans>
----

The main advantage of this DAO style is that it depends on JDO API only; no import of
any Spring class is required. This is of course appealing from a non-invasiveness
perspective, and might feel more natural to JDO developers.

However, the DAO throws plain `JDOException` (which is unchecked, so does not have to be
declared or caught), which means that callers can only treat exceptions as fatal, unless
you want to depend on JDO's own exception structure. Catching specific causes such as an
optimistic locking failure is not possible without tying the caller to the
implementation strategy. This trade off might be acceptable to applications that are
strongly JDO-based and/or do not need any special exception treatment.

In summary, you can DAOs based on the plain JDO API, and they can still participate in
Spring-managed transactions. This strategy might appeal to you if you are already
familiar with JDO. However, such DAOs throw plain `JDOException`, and you would have to
convert explicitly to Spring's `DataAccessException` (if desired).



[[orm-jdo-tx]]
==== Transaction management
[NOTE]
====
You are __strongly__ encouraged to read <<transaction-declarative>> if you have not done
so, to get a more detailed coverage of Spring's declarative transaction support.
====

To execute service operations within transactions, you can use Spring's common
declarative transaction facilities. For example:

[source,xml,indent=0]
[subs="verbatim"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			http://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			http://www.springframework.org/schema/aop/spring-aop.xsd">

		<bean id="myTxManager" class="org.springframework.orm.jdo.JdoTransactionManager">
			<property name="persistenceManagerFactory" ref="myPmf"/>
		</bean>

		<bean id="myProductService" class="product.ProductServiceImpl">
			<property name="productDao" ref="myProductDao"/>
		</bean>

		<tx:advice id="txAdvice" transaction-manager="txManager">
			<tx:attributes>
				<tx:method name="increasePrice*" propagation="REQUIRED"/>
				<tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/>
				<tx:method name="*" propagation="SUPPORTS" read-only="true"/>
			</tx:attributes>
		</tx:advice>

		<aop:config>
			<aop:pointcut id="productServiceMethods"
					expression="execution(* product.ProductService.*(..))"/>
			<aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/>
		</aop:config>

	</beans>
----

JDO requires an active transaction to modify a persistent object. The non-transactional
flush concept does not exist in JDO, in contrast to Hibernate. For this reason, you need
to set up the chosen JDO implementation for a specific environment. Specifically, you
need to set it up explicitly for JTA synchronization, to detect an active JTA
transaction itself. This is not necessary for local transactions as performed by
Spring's `JdoTransactionManager`, but it is necessary to participate in JTA
transactions, whether driven by Spring's `JtaTransactionManager` or by EJB CMT and plain
JTA.

`JdoTransactionManager` is capable of exposing a JDO transaction to JDBC access code
that accesses the same JDBC `DataSource`, provided that the registered `JdoDialect`
supports retrieval of the underlying JDBC `Connection`. This is the case for JDBC-based
JDO 2.0 implementations by default.



[[orm-jdo-dialect]]
==== JdoDialect

As an advanced feature, both `JdoTemplate` and `JdoTransactionManager` support a custom
`JdoDialect` that can be passed into the `jdoDialect` bean property. In this scenario,
the DAOs will not receive a `PersistenceManagerFactory` reference but rather a full
`JdoTemplate` instance (for example, passed into the `jdoTemplate` property of
`JdoDaoSupport`). Using a `JdoDialect` implementation, you can enable advanced features
supported by Spring, usually in a vendor-specific manner:

* Applying specific transaction semantics such as custom isolation level or transaction
  timeout
* Retrieving the transactional JDBC `Connection` for exposure to JDBC-based DAOs
* Applying query timeouts, which are automatically calculated from Spring-managed
  transaction timeouts
* Eagerly flushing a `PersistenceManager,` to make transactional changes visible to
  JDBC-based data access code
* Advanced translation of `JDOExceptions` to Spring `DataAccessExceptions`

See the `JdoDialect` javadocs for more details on its operations and how to use them
within Spring's JDO support.




[[orm-jpa]]
=== JPA
The Spring JPA, available under the `org.springframework.orm.jpa` package, offers
comprehensive support for the
http://www.oracle.com/technetwork/articles/javaee/jpa-137156.html[Java Persistence
API] in a similar manner to the integration with Hibernate or JDO, while being aware of
the underlying implementation in order to provide additional features.



[[orm-jpa-setup]]
==== Three options for JPA setup in a Spring environment
The Spring JPA support offers three ways of setting up the JPA `EntityManagerFactory`
that will be used by the application to obtain an entity manager.


[[orm-jpa-setup-lemfb]]
===== LocalEntityManagerFactoryBean

[NOTE]
====
Only use this option in simple deployment environments such as stand-alone applications
and integration tests.
====

The `LocalEntityManagerFactoryBean` creates an `EntityManagerFactory` suitable for
simple deployment environments where the application uses only JPA for data access. The
factory bean uses the JPA `PersistenceProvider` autodetection mechanism (according to
JPA's Java SE bootstrapping) and, in most cases, requires you to specify only the
persistence unit name:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>
		<bean id="myEmf" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean">
			<property name="persistenceUnitName" value="myPersistenceUnit"/>
		</bean>
	</beans>
----

This form of JPA deployment is the simplest and the most limited. You cannot refer to an
existing JDBC `DataSource` bean definition and no support for global transactions
exists. Furthermore, weaving (byte-code transformation) of persistent classes is
provider-specific, often requiring a specific JVM agent to specified on startup. This
option is sufficient only for stand-alone applications and test environments, for which
the JPA specification is designed.


[[orm-jpa-setup-jndi]]
===== Obtaining an EntityManagerFactory from JNDI

[NOTE]
====
Use this option when deploying to a Java EE 5 server. Check your server's documentation
on how to deploy a custom JPA provider into your server, allowing for a different
provider than the server's default.
====

Obtaining an `EntityManagerFactory` from JNDI (for example in a Java EE 5 environment),
is simply a matter of changing the XML configuration:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>
		<jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/>
	</beans>
----

This action assumes standard Java EE 5 bootstrapping: the Java EE server autodetects
persistence units (in effect, `META-INF/persistence.xml` files in application jars) and
`persistence-unit-ref` entries in the Java EE deployment descriptor (for example,
`web.xml`) and defines environment naming context locations for those persistence units.

In such a scenario, the entire persistence unit deployment, including the weaving
(byte-code transformation) of persistent classes, is up to the Java EE server. The JDBC
`DataSource` is defined through a JNDI location in the `META-INF/persistence.xml` file;
EntityManager transactions are integrated with the server's JTA subsystem. Spring merely
uses the obtained `EntityManagerFactory`, passing it on to application objects through
dependency injection, and managing transactions for the persistence unit, typically
through `JtaTransactionManager`.

If multiple persistence units are used in the same application, the bean names of such
JNDI-retrieved persistence units should match the persistence unit names that the
application uses to refer to them, for example, in `@PersistenceUnit` and
`@PersistenceContext` annotations.


[[orm-jpa-setup-lcemfb]]
===== LocalContainerEntityManagerFactoryBean

[NOTE]
====
Use this option for full JPA capabilities in a Spring-based application environment.
This includes web containers such as Tomcat as well as stand-alone applications and
integration tests with sophisticated persistence requirements.
====

The `LocalContainerEntityManagerFactoryBean` gives full control over
`EntityManagerFactory` configuration and is appropriate for environments where
fine-grained customization is required. The `LocalContainerEntityManagerFactoryBean`
creates a `PersistenceUnitInfo` instance based on the `persistence.xml` file, the
supplied `dataSourceLookup` strategy, and the specified `loadTimeWeaver`. It is thus
possible to work with custom data sources outside of JNDI and to control the weaving
process. The following example shows a typical bean definition for a
`LocalContainerEntityManagerFactoryBean`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>
		<bean id="myEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
			<property name="dataSource" ref="someDataSource"/>
			<property name="loadTimeWeaver">
				<bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/>
			</property>
		</bean>
	</beans>
----

The following example shows a typical `persistence.xml` file:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
		<persistence-unit name="myUnit" transaction-type="RESOURCE_LOCAL">
			<mapping-file>META-INF/orm.xml</mapping-file>
			<exclude-unlisted-classes/>
		</persistence-unit>
	</persistence>
----

[NOTE]
====
The `<exclude-unlisted-classes/>` shortcut indicates that __no__ scanning for
annotated entity classes is supposed to occur. An explicit 'true' value specified -
`<exclude-unlisted-classes>true</exclude-unlisted-classes/>` - also means no scan.
`<exclude-unlisted-classes>false</exclude-unlisted-classes/>` does trigger a scan;
however, it is recommended to simply omit the `exclude-unlisted-classes` element
if you want entity class scanning to occur.
====

Using the `LocalContainerEntityManagerFactoryBean` is the most powerful JPA setup
option, allowing for flexible local configuration within the application. It supports
links to an existing JDBC `DataSource`, supports both local and global transactions, and
so on. However, it also imposes requirements on the runtime environment, such as the
availability of a weaving-capable class loader if the persistence provider demands
byte-code transformation.

This option may conflict with the built-in JPA capabilities of a Java EE 5 server. In a
full Java EE 5 environment, consider obtaining your `EntityManagerFactory` from JNDI.
Alternatively, specify a custom `persistenceXmlLocation` on your
`LocalContainerEntityManagerFactoryBean` definition, for example,
META-INF/my-persistence.xml, and only include a descriptor with that name in your
application jar files. Because the Java EE 5 server only looks for default
`META-INF/persistence.xml` files, it ignores such custom persistence units and hence
avoid conflicts with a Spring-driven JPA setup upfront. (This applies to Resin 3.1, for
example.)

.When is load-time weaving required?
****
Not all JPA providers require a JVM agent ; Hibernate is an example of one that does
not. If your provider does not require an agent or you have other alternatives, such as
applying enhancements at build time through a custom compiler or an ant task, the
load-time weaver __should not__ be used.
****

The `LoadTimeWeaver` interface is a Spring-provided class that allows JPA
`ClassTransformer` instances to be plugged in a specific manner, depending whether the
environment is a web container or application server. Hooking `ClassTransformers`
through an
http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html[agent]
typically is not efficient. The agents work against the __entire virtual machine__ and
inspect __every__ class that is loaded, which is usually undesirable in a production
server environment.

Spring provides a number of `LoadTimeWeaver` implementations for various environments,
allowing `ClassTransformer` instances to be applied only __per class loader__ and not
per VM.

Refer to <<aop-aj-ltw-spring>> in the AOP chapter for more insight regarding the
`LoadTimeWeaver` implementations and their setup, either generic or customized to
various platforms (such as Tomcat, WebLogic, GlassFish, Resin and JBoss).

As described in the aforementioned section, you can configure a context-wide
`LoadTimeWeaver` using the `@EnableLoadTimeWeaving` annotation of
`context:load-time-weaver` XML element. Such a global weaver is picked up by all JPA
`LocalContainerEntityManagerFactoryBeans` automatically. This is the preferred way of
setting up a load-time weaver, delivering autodetection of the platform (WebLogic,
GlassFish, Tomcat, Resin, JBoss or VM agent) and automatic propagation of the weaver to
all weaver-aware beans:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<context:load-time-weaver/>
	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		...
	</bean>
----

However, if needed, one can manually specify a dedicated weaver through the
`loadTimeWeaver` property:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="loadTimeWeaver">
			<bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/>
		</property>
	</bean>
----

No matter how the LTW is configured, using this technique, JPA applications relying on
instrumentation can run in the target platform (ex: Tomcat) without needing an agent.
This is important especially when the hosting applications rely on different JPA
implementations because the JPA transformers are applied only at class loader level and
thus are isolated from each other.


[[orm-jpa-multiple-pu]]
===== Dealing with multiple persistence units
For applications that rely on multiple persistence units locations, stored in various
JARS in the classpath, for example, Spring offers the `PersistenceUnitManager` to act as
a central repository and to avoid the persistence units discovery process, which can be
expensive. The default implementation allows multiple locations to be specified that are
parsed and later retrieved through the persistence unit name. (By default, the classpath
is searched for `META-INF/persistence.xml` files.)

[source,xml,indent=0]
[subs="verbatim"]
----
	<bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager">
		<property name="persistenceXmlLocations">
			<list>
				<value>org/springframework/orm/jpa/domain/persistence-multi.xml</value>
				<value>classpath:/my/package/**/custom-persistence.xml</value>
				<value>classpath*:META-INF/persistence.xml</value>
			</list>
		</property>
		<property name="dataSources">
			<map>
				<entry key="localDataSource" value-ref="local-db"/>
				<entry key="remoteDataSource" value-ref="remote-db"/>
			</map>
		</property>
		<!-- if no datasource is specified, use this one -->
		<property name="defaultDataSource" ref="remoteDataSource"/>
	</bean>

	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="persistenceUnitManager" ref="pum"/>
		<property name="persistenceUnitName" value="myCustomUnit"/>
	</bean>
----

The default implementation allows customization of the `PersistenceUnitInfo` instances,
before they are fed to the JPA provider, declaratively through its properties, which
affect __all__ hosted units, or programmatically, through the
`PersistenceUnitPostProcessor`, which allows persistence unit selection. If no
`PersistenceUnitManager` is specified, one is created and used internally by
`LocalContainerEntityManagerFactoryBean`.



[[orm-jpa-straight]]
==== Implementing DAOs based on plain JPA
[NOTE]
====
Although `EntityManagerFactory` instances are thread-safe, `EntityManager` instances are
not. The injected JPA `EntityManager` behaves like an `EntityManager` fetched from an
application server's JNDI environment, as defined by the JPA specification. It delegates
all calls to the current transactional `EntityManager`, if any; otherwise, it falls back
to a newly created `EntityManager` per operation, in effect making its usage thread-safe.
====

It is possible to write code against the plain JPA without any Spring dependencies, by
using an injected `EntityManagerFactory` or `EntityManager`. Spring can understand
`@PersistenceUnit` and `@PersistenceContext` annotations both at field and method level
if a `PersistenceAnnotationBeanPostProcessor` is enabled. A plain JPA DAO implementation
using the `@PersistenceUnit` annotation might look like this:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class ProductDaoImpl implements ProductDao {

		private EntityManagerFactory emf;

		@PersistenceUnit
		public void setEntityManagerFactory(EntityManagerFactory emf) {
			this.emf = emf;
		}

		public Collection loadProductsByCategory(String category) {
			EntityManager em = this.emf.createEntityManager();
			try {
				Query query = em.createQuery("from Product as p where p.category = ?1");
				query.setParameter(1, category);
				return query.getResultList();
			}
			finally {
				if (em != null) {
					em.close();
				}
			}
		}
	}
----

The DAO above has no dependency on Spring and still fits nicely into a Spring
application context. Moreover, the DAO takes advantage of annotations to require the
injection of the default `EntityManagerFactory`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<!-- bean post-processor for JPA annotations -->
		<bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/>

		<bean id="myProductDao" class="product.ProductDaoImpl"/>

	</beans>
----

As an alternative to defining a `PersistenceAnnotationBeanPostProcessor` explicitly,
consider using the Spring `context:annotation-config` XML element in your application
context configuration. Doing so automatically registers all Spring standard
post-processors for annotation-based configuration, including
`CommonAnnotationBeanPostProcessor` and so on.

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<!-- post-processors for all standard config annotations -->
		<context:annotation-config/>

		<bean id="myProductDao" class="product.ProductDaoImpl"/>

	</beans>
----

The main problem with such a DAO is that it always creates a new `EntityManager` through
the factory. You can avoid this by requesting a transactional `EntityManager` (also
called "shared EntityManager" because it is a shared, thread-safe proxy for the actual
transactional EntityManager) to be injected instead of the factory:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class ProductDaoImpl implements ProductDao {

		@PersistenceContext
		private EntityManager em;

		public Collection loadProductsByCategory(String category) {
			Query query = em.createQuery("from Product as p where p.category = :category");
			query.setParameter("category", category);
			return query.getResultList();
		}
	}
----

The `@PersistenceContext` annotation has an optional attribute `type`, which defaults to
`PersistenceContextType.TRANSACTION`. This default is what you need to receive a shared
EntityManager proxy. The alternative, `PersistenceContextType.EXTENDED`, is a completely
different affair: This results in a so-called extended EntityManager, which is __not
thread-safe__ and hence must not be used in a concurrently accessed component such as a
Spring-managed singleton bean. Extended EntityManagers are only supposed to be used in
stateful components that, for example, reside in a session, with the lifecycle of the
EntityManager not tied to a current transaction but rather being completely up to the
application.

.Method- and field-level Injection
****
Annotations that indicate dependency injections (such as `@PersistenceUnit` and
`@PersistenceContext`) can be applied on field or methods inside a class, hence the
expressions __method-level injection__ and __field-level injection__. Field-level
annotations are concise and easier to use while method-level allows for further
processing of the injected dependency. In both cases the member visibility (public,
protected, private) does not matter.

What about class-level annotations?

On the Java EE 5 platform, they are used for dependency declaration and not for resource
injection.
****

The injected `EntityManager` is Spring-managed (aware of the ongoing transaction). It is
important to note that even though the new DAO implementation uses method level
injection of an `EntityManager` instead of an `EntityManagerFactory`, no change is
required in the application context XML due to annotation usage.

The main advantage of this DAO style is that it only depends on Java Persistence API; no
import of any Spring class is required. Moreover, as the JPA annotations are understood,
the injections are applied automatically by the Spring container. This is appealing from
a non-invasiveness perspective, and might feel more natural to JPA developers.



[[orm-jpa-tx]]
==== Transaction Management
[NOTE]
====
You are __strongly__ encouraged to read <<transaction-declarative>> if you have not done
so, to get a more detailed coverage of Spring's declarative transaction support.
====

To execute service operations within transactions, you can use Spring's common
declarative transaction facilities. For example:

[source,xml,indent=0]
[subs="verbatim"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			http://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			http://www.springframework.org/schema/aop/spring-aop.xsd">

		<bean id="myTxManager" class="org.springframework.orm.jpa.JpaTransactionManager">
			<property name="entityManagerFactory" ref="myEmf"/>
		</bean>

		<bean id="myProductService" class="product.ProductServiceImpl">
			<property name="productDao" ref="myProductDao"/>
		</bean>

		<aop:config>
			<aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/>
			<aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/>
		</aop:config>

		<tx:advice id="txAdvice" transaction-manager="myTxManager">
			<tx:attributes>
				<tx:method name="increasePrice*" propagation="REQUIRED"/>
				<tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/>
				<tx:method name="*" propagation="SUPPORTS" read-only="true"/>
			</tx:attributes>
		</tx:advice>

	</beans>
----

Spring JPA allows a configured `JpaTransactionManager` to expose a JPA transaction to
JDBC access code that accesses the same JDBC `DataSource`, provided that the registered
`JpaDialect` supports retrieval of the underlying JDBC `Connection`. Out of the box,
Spring provides dialects for the Toplink, Hibernate and OpenJPA JPA implementations. See
the next section for details on the `JpaDialect` mechanism.



[[orm-jpa-dialect]]
==== JpaDialect

As an advanced feature `JpaTemplate`, `JpaTransactionManager` and subclasses of
`AbstractEntityManagerFactoryBean` support a custom `JpaDialect`, to be passed into the
`jpaDialect` bean property. In such a scenario, the DAOs do not receive an
`EntityManagerFactory` reference but rather a full `JpaTemplate` instance (for example,
passed into the `jpaTemplate` property of `JpaDaoSupport`). A `JpaDialect`
implementation can enable some advanced features supported by Spring, usually in a
vendor-specific manner:

* Applying specific transaction semantics such as custom isolation level or transaction
  timeout)
* Retrieving the transactional JDBC `Connection` for exposure to JDBC-based DAOs)
* Advanced translation of `PersistenceExceptions` to Spring `DataAccessExceptions`

This is particularly valuable for special transaction semantics and for advanced
translation of exception. The default implementation used ( `DefaultJpaDialect`) does
not provide any special capabilities and if the above features are required, you have to
specify the appropriate dialect.

See the `JpaDialect` javadocs for more details of its operations and how they are used
within Spring's JPA support.