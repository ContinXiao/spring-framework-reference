<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>15.&nbsp;&#23545;&#35937;&#20851;&#31995;&#26144;&#23556;(ORM)&#25968;&#25454;&#35775;&#38382;</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="spring-data-tier.html" title="Part&nbsp;IV.&nbsp;Data Access"><link rel="prev" href="jdbc.html" title="14.&nbsp;Data access with JDBC"><link rel="next" href="oxm.html" title="16.&nbsp;Marshalling XML using O/X Mappers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">15.&nbsp;&#23545;&#35937;&#20851;&#31995;&#26144;&#23556;(ORM)&#25968;&#25454;&#35775;&#38382;</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="jdbc.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Data Access</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="oxm.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="orm" href="#orm"></a>15.&nbsp;&#23545;&#35937;&#20851;&#31995;&#26144;&#23556;(ORM)&#25968;&#25454;&#35775;&#38382;</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-introduction" href="#orm-introduction"></a>15.1&nbsp;&#20171;&#32461; Spring &#20013;&#30340; ORM</h2></div></div></div>

<p>Spring Framework &#25903;&#25345;&#38598;&#25104;  Hibernate, Java Persistence API (JPA) &#21644; Java Data Objects (JDO) &#29992;&#20110;&#36164;&#28304;&#31649;&#29702;&#12289;&#25968;&#25454;&#35775;&#38382;&#23545;&#35937;(DAO)&#30340;&#23454;&#29616;,&#21644;&#20107;&#21153;&#31574;&#30053;&#12290;&#20363;&#22914;,&#23545;&#20110; Hibernate &#26377;&#19968;&#27969;&#30340;&#25903;&#25345;&#65292;&#20351;&#29992;&#26041;&#20415;&#30340; IoC &#29305;&#24615;,&#35299;&#20915;&#35768;&#22810;&#20856;&#22411;&#30340; Hibernate &#38598;&#25104;&#38382;&#39064;&#12290;&#24744;&#21487;&#20197;&#36890;&#36807;&#20381;&#36182;&#27880;&#20837;&#37197;&#32622;&#30340;&#25152;&#26377;  O/R (&#23545;&#35937;&#20851;&#31995;) &#26144;&#23556;&#24037;&#20855;&#30340;&#29305;&#24615;&#12290;&#20182;&#20204;&#21487;&#20197;&#21442;&#19982; Spring &#30340;&#36164;&#28304;&#21644;&#20107;&#21153;&#31649;&#29702;,&#20182;&#20204;&#31526;&#21512; Spring &#30340;&#36890;&#29992;&#20107;&#21153;&#21644; DAO &#24322;&#24120;&#23618;&#27425;&#32467;&#26500;&#12290;&#24314;&#35758;&#38598;&#25104;&#39118;&#26684;&#26159;&#22312; Hibernate, JPA, &#21644; JDO APIs &#20013;&#20351;&#29992; DAO &#12290;&#26087;&#30340; Spring DAO &#27169;&#26495;&#19981;&#20877;&#25512;&#33616;&#20351;&#29992;;&#28982;&#32780;,&#20851;&#20110;&#39118;&#26684;&#30340;&#35770;&#36848;&#21487;&#20197;&#35265;
<a class="xref" href="classic-spring.html#classic-spring-orm" title="32.1&nbsp;Classic ORM usage">Section&nbsp;32.1, &#8220;Classic ORM usage&#8221;</a> .</p>
<p>&#24403;&#20320;&#21019;&#24314;&#25968;&#25454;&#35775;&#38382;&#24212;&#29992;&#26102;&#65292;Spring &#33021;&#23545;&#20320;&#36873;&#25321;&#30340; ORM &#23618;&#36827;&#34892;&#26174;&#30528;&#30340;&#22686;&#24378;&#12290;&#20320;&#26681;&#25454;&#20320;&#30340;&#38656;&#27714;&#36827;&#34892;&#23613;&#21487;&#33021;&#22810;&#30340;&#38598;&#25104;&#25903;&#25345;&#65292;&#21516;&#26102;&#38656;&#35201;&#27604;&#36825;&#31181;&#25972;&#21512;&#22312;&#24314;&#19968;&#20010;&#31867;&#20284;&#30340;&#22522;&#30784;&#35774;&#26045;&#26102;&#30340;&#20869;&#37096;&#39118;&#38505;&#12290;&#36890;&#36807;&#24211;&#65292;&#20320;&#21487;&#20197;&#20351;&#29992;&#24456;&#22810;&#30340; ORM &#30340;&#25903;&#25345;&#65292;&#19981;&#29992;&#31649;&#25216;&#26415;&#65292;&#22240;&#20026;&#19968;&#20999;&#37117;&#26159;&#35774;&#35745;&#25104;&#19968;&#32452;&#21487;&#37325;&#29992;&#30340; JavaBean&#12290;ORM &#22312; Spring IoC &#23481;&#22120;&#20415;&#20110;&#37197;&#32622;&#21644;&#37096;&#32626;&#12290;&#22240;&#27492;&#65292;&#26412;&#25991;&#20013;&#30340;&#22823;&#22810;&#25968;&#31034;&#20363;&#37197;&#32622;&#26174;&#31034;&#22312; Spring &#23481;&#22120;&#37324;&#12290;</p>
<p>&#20351;&#29992; Spring Framework &#26469;&#21019;&#24314;&#24744;&#30340; ORM DAO &#22909;&#22788;&#21253;&#25324;:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>&#26356;&#23481;&#26131;&#27979;&#35797;.</em></span> Spring &#30340; IoC &#26041;&#27861;&#20415;&#20110;&#20132;&#25442;&#23454;&#29616;&#21644;&#37197;&#32622; Hibernate <code class="literal">SessionFactory</code> &#23454;&#20363;,JDBC <code class="literal">DataSource</code>(&#25968;&#25454;&#28304;)&#23454;&#20363;,&#20107;&#21153;&#31649;&#29702;,&#20197;&#21450;&#26144;&#23556;&#23545;&#35937;&#23454;&#29616;(&#22914;&#26524;&#38656;&#35201;)&#12290;&#36825;&#21453;&#36807;&#26469;&#20351;&#20854;&#26356;&#23481;&#26131;&#38548;&#31163;&#27979;&#35797;&#27599;&#19968;&#22359;&#25345;&#32493;&#30456;&#20851;&#20195;&#30721;&#12290;
</li><li class="listitem">
<span class="emphasis"><em>&#24120;&#35265;&#30340;&#25968;&#25454;&#35775;&#38382;&#24322;&#24120;.</em></span> Spring &#21487;&#20197;&#20174;&#20320;&#30340; ORM &#24037;&#20855;&#21253;&#35013;&#24322;&#24120;,&#23558;&#20182;&#20204;&#20174;&#19987;&#26377;&#30340;(&#21487;&#33021;&#26816;&#26597;)&#24322;&#24120;&#36716;&#20026;&#20849;&#21516;&#36816;&#34892;&#26102; DataAccessException &#23618;&#27425;&#12290;&#36825;&#20010;&#29305;&#24615;&#20801;&#35768;&#24744;&#22788;&#29702;&#22823;&#22810;&#25968;&#25345;&#20037;&#21270;&#30340;&#24322;&#24120;&#19981;&#21487;&#24674;&#22797;&#30340;&#65292;&#32780;&#19988;&#21482;&#20986;&#29616;&#22312;&#36866;&#24403;&#30340;&#23618;,&#27809;&#26377;&#24700;&#20154;&#30340;&#25429;&#25417;&#12289;&#25243;&#20986;&#12289;&#21644;&#24322;&#24120;&#22768;&#26126;&#12290;&#24403;&#28982;&#26681;&#25454;&#38656;&#35201;&#20320;&#20173;&#28982;&#21487;&#20197;&#25429;&#33719;&#21644;&#22788;&#29702;&#24322;&#24120;&#12290;&#35760;&#20303;,JDBC &#24322;&#24120;(&#21253;&#25324;&#25968;&#25454;&#24211;&#29305;&#27530;&#30340;&#26041;&#35328;)&#20063;&#36716;&#25442;&#20026;&#30456;&#21516;&#30340;&#23618;&#27425;&#32467;&#26500;,&#36825;&#24847;&#21619;&#30528;&#24744;&#21487;&#20197;&#22312;&#20351;&#29992; JDBC &#25191;&#34892;&#19968;&#20123;&#25805;&#20316;&#26102;&#25317;&#26377;&#19968;&#33268;&#30340;&#32534;&#31243;&#27169;&#22411;&#12290;
</li><li class="listitem">
<span class="emphasis"><em>&#36890;&#29992;&#36164;&#28304;&#31649;&#29702;.</em></span> Spring &#24212;&#29992;&#31243;&#24207;&#19978;&#19979;&#25991;&#21487;&#20197;&#22788;&#29702;&#30340;&#23450;&#20301;&#21644;&#37197;&#32622;Hibernate <code class="literal">SessionFactory</code> &#23454;&#20363;,JPA <code class="literal">EntityManagerFactory</code>&#23454;&#20363;,JDBC <code class="literal">DataSource</code>(&#25968;&#25454;&#28304;)&#23454;&#20363;,&#21644;&#20854;&#20182;&#30456;&#20851;&#36164;&#28304;&#12290;&#36825;&#20351;&#24471;&#36825;&#20123;&#20540;&#26131;&#20110;&#31649;&#29702;&#21644;&#25913;&#21464;&#12290;Spring &#25552;&#20379;&#20102;&#39640;&#25928;&#12289;&#31616;&#21333;&#21644;&#23433;&#20840;&#22788;&#29702;&#25345;&#20037;&#24615;&#30340;&#36164;&#28304;&#12290;&#20363;&#22914;,&#20851;&#32852;&#20195;&#30721;&#26469;&#20351;&#29992; Hibernate &#65292;&#36890;&#24120;&#38656;&#35201;&#20351;&#29992;&#30456;&#21516;&#30340; Hibernate <code class="literal">Session</code>,&#20197;&#30830;&#20445;&#39640;&#25928;&#21644;&#36866;&#24403;&#30340;&#20107;&#21153;&#22788;&#29702;&#12290;Spring &#24456;&#23481;&#26131;&#21019;&#24314;&#21644;&#36879;&#26126;&#22320;&#23558;<code class="literal">Session</code>&#32465;&#23450;&#21040;&#24403;&#21069;&#32447;&#31243;,&#36890;&#36807;&#20351;&#29992; Hibernate <code class="literal">SessionFactory</code> &#26469;&#26292;&#38706;&#20986;&#24403;&#21069;<code class="literal">Session</code>&#12290;&#22240;&#27492;&#65292;&#38024;&#23545;&#20219;&#20309;&#26412;&#22320;&#25110; JTA &#20107;&#21153;&#29615;&#22659;&#65292;Spring &#35299;&#20915;&#35768;&#22810;&#22312;&#20856;&#22411;&#30340; Hibernate &#20351;&#29992;&#20013;&#30340;&#24815;&#24615;&#38382;&#39064;&#12290;
</li><li class="listitem">
<span class="emphasis"><em>&#38598;&#25104;&#20107;&#21153;&#31649;&#29702;.</em></span> &#21487;&#20197;&#36890;&#36807;&#22768;&#26126;&#24335;&#30340;,&#38754;&#21521;&#26041;&#38754;&#30340;&#32534;&#31243;(AOP)&#39118;&#26684;&#26041;&#27861;&#25318;&#25130;&#22120;&#21253;&#35013;&#20320;&#30340; ORM &#20195;&#30721;&#36890;&#36807;&#21527;&#65292;&#21487;&#20197;&#37319;&#29992;<code class="literal">@Transactional</code>&#27880;&#37322;&#25110;&#36890;&#36807;&#26174;&#24335;&#37197;&#32622;&#20107;&#21153; AOP advice &#22312;&#19968;&#20010; XML &#37197;&#32622;&#25991;&#20214;&#20013;&#12290;&#22312;&#36825;&#20004;&#31181;&#24773;&#20917;&#19979;,&#37117;&#26159;&#21487;&#20197;&#20026;&#24744;&#22788;&#29702;&#20107;&#21153;&#35821;&#20041;&#21644;&#24322;&#24120;&#22788;&#29702;(&#22238;&#28378;,&#31561;&#31561;)&#12290;&#22914;&#19979;&#38754;&#25152;&#35752;&#35770;&#30340;
<a class="link" href="orm.html#orm-resource-mngmnt" title="15.2.1&nbsp;&#36164;&#28304;&#21644;&#20107;&#21153;&#31649;&#29702;">Resource and transaction management</a>, &#20320;&#20063;&#21487;&#20197;&#20132;&#25442;&#19981;&#21516;&#30340;&#20107;&#21153;&#31649;&#29702;&#22120;,&#32780;&#19981;&#24433;&#21709; ORM &#30456;&#20851;&#30340;&#20195;&#30721;&#12290;&#20363;&#22914;,&#24744;&#21487;&#20197;&#22312;&#30456;&#21516;&#30340;&#20840;&#38754;&#26381;&#21153;(&#22914;&#22768;&#26126;&#24615;&#20107;&#21153;)&#30340;&#20004;&#20010;&#22330;&#26223;&#65292;&#23454;&#29616;&#26412;&#22320;&#20107;&#21153;&#21644; JTA &#20043;&#38388;&#20132;&#25442;&#12290;&#21478;&#22806;,JDBC &#30456;&#20851;&#30340;&#20195;&#30721;&#21487;&#20197;&#23436;&#20840;&#38598;&#25104;&#20107;&#21153;&#21040;&#20320;&#20351;&#29992;&#30340; ORM &#20195;&#30721;&#20013;&#12290;&#36825;&#26159;&#23545;&#20110;&#25968;&#25454;&#35775;&#38382;&#26377;&#29992;,&#20294;&#19981;&#36866;&#21512; ORM &#20013;&#30340;&#25209;&#22788;&#29702;&#21644; BLOB &#27969;&#31561;,&#36825;&#20173;&#28982;&#38656;&#35201;&#22312;ORM&#25805;&#20316; &#20132;&#25442;&#20849;&#21516;&#30340;&#20107;&#21153;&#12290;
</li></ul></div>

<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>&#20026;&#26356;&#20840;&#38754;&#20102;&#35299;&#30340; ORM &#30340;&#25903;&#25345;,&#21253;&#25324;&#25903;&#25345;&#26367;&#20195;&#25968;&#25454;&#24211;&#25216;&#26415;,&#22914; MongoDB &#25968;&#25454;&#24211;,&#24744;&#21487;&#33021;&#24076;&#26395;&#26597;&#30475;
<a class="ulink" href="http://projects.spring.io/spring-data/" target="_top">Spring Data</a> &#37197;&#22871;&#30340;&#39033;&#30446;&#12290;&#22914;&#26524;&#20320;&#26159;&#19968;&#20010; JPA &#29992;&#25143; <a class="ulink" href="https://spring.io/guides/gs/accessing-data-jpa/" target="_top">Getting Started Accessing
Data with JPA</a> &#25552;&#20379;&#20102;&#19968;&#20010;&#24456;&#22909;&#30340;&#20171;&#32461;.</p>
</td></tr></table></div>

</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-general" href="#orm-general"></a>15.2&nbsp;&#24120;&#35265;&#30340; ORM &#38598;&#25104;&#26041;&#38754;&#30340;&#27880;&#24847;&#20107;&#39033;</h2></div></div></div>

<p>&#26412;&#33410;&#24378;&#35843;&#30340; &#27880;&#24847;&#20107;&#39033;&#24212;&#29992;&#19982;&#25152;&#26377;&#30340; ORM &#25216;&#26415;&#12290;
<a class="xref" href="orm.html#orm-hibernate" title="15.3&nbsp;Hibernate">Section&nbsp;15.3, &#8220;Hibernate&#8221;</a> &#36825;&#33410;&#25552;&#20379;&#20102;&#26356;&#22810;&#32454;&#33410;&#65292;&#21516;&#26102;&#23637;&#31034;&#20102;&#36825;&#20123;&#29305;&#24615;&#21644;&#20855;&#20307;&#19978;&#19979;&#25991;&#30340;&#37197;&#32622;&#12290;</p>
<p>Spring &#30340; ORM &#38598;&#25104;&#30340;&#20027;&#35201;&#30446;&#26631;&#26159;&#26126;&#30830;&#30340;&#24212;&#29992;&#31243;&#24207;&#20998;&#23618;,&#21253;&#25324;&#22312;&#20219;&#20309;&#25968;&#25454;&#35775;&#38382;&#12289;&#20107;&#21153;&#25216;&#26415;&#21644;&#26494;&#32806;&#21512;&#30340;&#24212;&#29992;&#31243;&#24207;&#23545;&#35937;&#12290;&#27809;&#26377;&#26356;&#22810;&#30340;&#19994;&#21153;&#26381;&#21153;&#20381;&#36182;&#20110;&#25968;&#25454;&#35775;&#38382;&#25110;&#20107;&#21153;&#31574;&#30053;,&#19981;&#20877;&#36164;&#28304;&#26597;&#25214;&#30828;&#32534;&#30721;,&#19981;&#20877;&#24378;&#21046;&#26367;&#25442;&#21333;&#20363;,&#27809;&#26377;&#26356;&#22810;&#30340;&#33258;&#23450;&#20041;&#26381;&#21153;&#27880;&#20876;&#12290;&#19968;&#20010;&#31616;&#21333;&#30340;&#21644;&#19968;&#33268;&#30340;&#26041;&#27861;&#26469;&#36830;&#25509;&#24212;&#29992;&#31243;&#24207;&#23545;&#35937;,&#35753;&#20182;&#20204;&#23613;&#21487;&#33021;&#30340;&#23545;&#23481;&#22120;&#20381;&#36182;&#26159;&#21487;&#20197;&#37325;&#29992;&#24182;&#19988;&#26159;&#33258;&#30001;&#12290;&#25152;&#26377;&#20010;&#20154;&#25968;&#25454;&#35775;&#38382;&#29305;&#24615;&#21487;&#29992;&#30340;,&#20294;&#21487;&#20197;&#19982;Spring &#24212;&#29992;&#31243;&#24207;&#19978;&#19979;&#25991;&#30340;&#27010;&#24565;&#38598;&#25104;,&#25552;&#20379;&#22522;&#20110; xml &#30340;&#37197;&#32622;&#21644;&#20132;&#21449;&#24341;&#29992;&#30340;&#26222;&#36890; JavaBean &#23454;&#20363;&#32780;&#19981;&#38656;&#35201; Spring-aware&#65288;Spring &#30340;&#24847;&#35782;&#65289;&#12290;&#22312;&#19968;&#20010;&#20856;&#22411;&#30340; Spring &#24212;&#29992;&#31243;&#24207;&#20013;,&#35768;&#22810;&#37325;&#35201;&#30340;&#23545;&#35937;&#26159; JavaBean:&#25968;&#25454;&#35775;&#38382;&#27169;&#26495;,&#25968;&#25454;&#35775;&#38382;&#23545;&#35937;,&#20107;&#21153;&#31649;&#29702;&#22120;,&#20351;&#29992;&#25968;&#25454;&#35775;&#38382;&#23545;&#35937;&#21644;&#20107;&#21153;&#31649;&#29702;&#22120;&#30340;&#19994;&#21153;&#26381;&#21153;, web &#35270;&#22270;&#35299;&#26512;&#22120;,&#20351;&#29992;&#19994;&#21153;&#26381;&#21153;&#30340; web &#25511;&#21046;&#22120;,&#31561;&#31561;&#12290;</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-resource-mngmnt" href="#orm-resource-mngmnt"></a>15.2.1&nbsp;&#36164;&#28304;&#21644;&#20107;&#21153;&#31649;&#29702;</h3></div></div></div>

<p>&#20856;&#22411;&#30340;&#21830;&#19994;&#24212;&#29992;&#26159;&#29992;&#37325;&#22797;&#30340;&#36164;&#28304;&#31649;&#29702;&#20195;&#30721;&#26434;&#20081;&#30340;&#22534;&#31215;&#36215;&#26469;&#30340;&#12290;&#24456;&#22810;&#39033;&#30446;&#35797;&#22270;&#21019;&#36896;&#33258;&#24049;&#30340;&#35299;&#20915;&#26041;&#26696;&#65292;&#26377;&#26102;&#20026;&#20102;&#32534;&#31243;&#26041;&#20415;&#26469;&#29306;&#29298;&#25925;&#38556;&#30340;&#22788;&#29702;&#12290;Spring &#25552;&#20513;&#31616;&#21333;&#30340;&#22788;&#29702;&#36866;&#24403;&#36164;&#28304;&#30340;&#26041;&#26696;&#65292;&#21363;&#22312;JDBC&#30340;&#26696;&#20363; IoC &#36890;&#36807;&#27169;&#26495;&#21644;&#22312; ORM &#25216;&#26415;&#24212;&#29992; AOP &#25318;&#25130;&#22120;&#12290;</p>
<p>&#22522;&#30784;&#35774;&#26045;&#25552;&#20379;&#36866;&#24403;&#30340;&#36164;&#28304;&#22788;&#29702;&#65292;&#24182;&#19988;&#33021;&#23558;&#29305;&#23450;&#30340; API &#24322;&#24120;&#36866;&#24403;&#30340;&#36716;&#25442;&#20026;&#19968;&#20010;&#26410;&#26816;&#26597;&#30340;&#22522;&#30784;&#30340;&#24322;&#24120;&#23618;&#27425;&#32467;&#26500;&#12290;Spring  &#24341;&#20837;&#20102; DAO &#24322;&#24120;&#23618;&#27425;&#32467;&#26500;&#65292;&#36866;&#29992;&#20110;&#20219;&#20309;&#30340;&#25968;&#25454;&#35775;&#38382;&#31574;&#30053;&#12290;&#23545;&#20110;&#30452;&#25509;&#30340; JDBC&#65292;&#22312;&#21069;&#19968;&#33410;&#25552;&#21040;&#30340;<code class="literal">JdbcTemplate</code>&#31867;&#25552;&#20379;&#20102;&#36830;&#25509;&#22788;&#29702;&#21644;&#23558; <code class="literal">SQLException</code> &#36866;&#24403;&#30340;&#36716;&#25442;&#20026;<code class="literal">DataAccessException</code> &#23618;&#27425;&#32467;&#26500;&#65292;&#20854;&#20013;&#21253;&#25324;&#23558; &#20855;&#20307;&#25968;&#25454;&#24211; SQL &#38169;&#35823;&#20195;&#30721;&#36716;&#20026;&#26377;&#24847;&#20041;&#30340;&#24322;&#24120;&#31867;&#12290;&#23545;&#20110; ORM &#25216;&#26415;&#65292;&#35265;&#19979;&#19968;&#33410;&#65292;&#22914;&#20309;&#24471;&#21040;&#30456;&#21516;&#24322;&#24120;&#36716;&#25442;&#30340;&#22909;&#22788;&#12290;</p>
<p>&#24403;&#28041;&#21450;&#21040;&#20107;&#21153;&#31649;&#29702;&#65292;<code class="literal">JdbcTemplate</code>&#31867;&#19982; Spring &#30340;&#20107;&#21153;&#25903;&#25345;&#25346;&#38057;&#65292;&#24182;&#19988;&#36890;&#36807;&#21508;&#33258;&#30340; Spring &#20107;&#21153;&#31649;&#29702;&#22120;&#25903;&#25345; JTA &#21644; JDBC &#20107;&#21153;&#12290;&#20026;&#25903;&#25345; ORM &#25216;&#26415; Spring &#25552;&#20379;&#20102;&#36890;&#36807;&#19982; JTA &#25903;&#25345;&#31867;&#20284;&#30340; Hibernate&#65292;JPA&#65292;&#21644; JDO &#20107;&#21153;&#31649;&#29702;&#22120;&#26469;&#23454;&#29616;&#23545; Hibernate&#65292;JPA &#21644; JDO &#25903;&#25345;&#12290;&#26356;&#22810;&#20107;&#21153;&#30340;&#25903;&#25345;&#65292;&#35814;&#32454;&#20449;&#24687;&#65292;&#21442; <a class="xref" href="transaction.html" title="12.&nbsp;Transaction Management">Chapter&nbsp;12, <i>Transaction Management</i></a> chapter.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-exception-translation" href="#orm-exception-translation"></a>15.2.2&nbsp;&#24322;&#24120;&#36716;&#21270;</h3></div></div></div>

<p>&#24403;&#20320;&#22312; DAO &#20013;&#20351;&#29992; Hibernate&#12289;JPA &#25110; JDO &#26102;,&#20320;&#24517;&#39035;&#20915;&#23450;&#22914;&#20309;&#22788;&#29702;&#25345;&#20037;&#21270;&#25216;&#26415;&#30340;&#21407;&#29983;&#24322;&#24120;&#31867;&#12290;&#36816;&#29992;&#19981;&#21516;&#30340;&#25216;&#26415;&#65292;DAO &#20250;&#25243;&#20986;<code class="literal">HibernateException</code>&#12289;<code class="literal">PersistenceException</code>&#25110;<code class="literal">JDOException</code> &#30340;&#23376;&#31867;&#12290;&#36825;&#20123;&#24322;&#24120;&#37117;&#26159;&#36816;&#34892;&#26102;&#30340;&#24322;&#24120;,&#19981;&#38656;&#35201;&#22768;&#26126;&#25110;&#25429;&#33719;&#12290;&#20320;&#21487;&#33021;&#24517;&#39035;&#22788;&#29702;<code class="literal">IllegalArgumentException</code> &#21644;<code class="literal">IllegalStateException</code>&#12290;&#36825;&#24847;&#21619;&#30528;&#35843;&#29992;&#32773;&#21482;&#33021;&#23558;&#24322;&#24120;&#22788;&#29702;&#25104;&#20026;&#19968;&#20010;&#36890;&#24120;&#20026;&#33268;&#21629;&#30340;&#38382;&#39064;,&#38500;&#38750;&#20182;&#20204;&#24819;&#35201;&#20381;&#36182;&#20110;&#25345;&#20037;&#21270;&#25216;&#26415;&#33258;&#36523;&#30340;&#24322;&#24120;&#32467;&#26500;&#12290;&#25429;&#25417;&#20048;&#35266;&#38145;&#23450;&#22833;&#36133;&#31561;&#20855;&#20307;&#21407;&#22240;&#26159;&#19981;&#21487;&#33021;&#30340;&#38500;&#38750;&#25226;&#35843;&#29992;&#32773;&#19982;&#23454;&#29616;&#31574;&#30053;&#30456;&#32852;&#31995;&#12290;&#21462;&#28040;&#36825;&#20132;&#25442;&#26159;&#21487;&#25509;&#21463;&#30340;&#23545;&#20110;&#24212;&#29992;&#31243;&#24207;&#26159;&#22522;&#20110; ORM &#21644;/&#25110; &#19981;&#38656;&#35201;&#20219;&#20309;&#29305;&#27530;&#30340;&#24322;&#24120;&#22788;&#29702;&#12290;&#28982;&#32780;,Spring &#36890;&#36807; <code class="literal">@Repository</code> &#27880;&#35299; &#26469;&#20351;&#24322;&#24120;&#36879;&#26126;&#30340;&#36716;&#21270;:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Repository</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-comment">// class body here...</span>

}</pre>

<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-comment">&lt;!-- Exception translation bean post processor --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>postprocessor &#20250;&#33258;&#21160;&#23547;&#25214;&#25152;&#26377;&#24322;&#24120;&#36716;&#25442;&#22120;( &#23454;&#29616; <code class="literal">PersistenceExceptionTranslator</code> &#25509;&#21475;),&#24314;&#35758;&#25152;&#26377; bean &#26631;&#26377;<code class="literal">@Repository</code>&#27880;&#35299;,&#20197;&#20415;&#21457;&#29616;&#30340;&#36716;&#25442;&#22120;&#21487;&#20197;&#22312;&#25243;&#20986;&#24322;&#24120;&#26102;&#25318;&#25130;&#21644;&#24212;&#29992;&#36866;&#24403;&#30340;&#36716;&#25442;&#12290;</p>
<p>&#24635;&#20043;:&#24744;&#21487;&#20197;&#23454;&#29616; DAO  &#22522;&#20110;&#32431;&#25345;&#20037;&#21270;&#25216;&#26415;&#30340;API&#21644;&#27880;&#35299;,&#21516;&#26102;&#20173;&#28982;&#21463;&#30410;&#20110;Spring &#31649;&#29702;&#20107;&#21153;,&#20381;&#36182;&#27880;&#20837;&#12289;&#21644;&#36879;&#26126;&#23558;&#24322;&#24120;&#36716;&#25442;(&#22914;&#26524;&#38656;&#35201;)&#20026; Spring &#30340;&#33258;&#23450;&#20041;&#30340;&#24322;&#24120;&#23618;&#27425;&#32467;&#26500;&#12290;</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-hibernate" href="#orm-hibernate"></a>15.3&nbsp;Hibernate</h2></div></div></div>

<p>We will start with a coverage of <a class="ulink" href="http://www.hibernate.org/" target="_top">Hibernate 3</a> in a Spring
environment, using it to demonstrate the approach that Spring takes towards integrating
O/R mappers. This section will cover many issues in detail and show different variations
of DAO implementations and transaction demarcation. Most of these patterns can be
directly translated to all other supported ORM tools. The following sections in this
chapter will then cover the other ORM technologies, showing briefer examples there.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>As of Spring 4.0, Spring requires Hibernate 3.6 or later.</p>
</td></tr></table></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-session-factory-setup" href="#orm-session-factory-setup"></a>15.3.1&nbsp;SessionFactory setup in a Spring container</h3></div></div></div>

<p>To avoid tying application objects to hard-coded resource lookups, you can define
resources such as a JDBC <code class="literal">DataSource</code> or a Hibernate <code class="literal">SessionFactory</code> as beans in the
Spring container. Application objects that need to access resources receive references
to such predefined instances through bean references, as illustrated in the DAO
definition in the next section.</p>
<p>The following excerpt from an XML application context definition shows how to set up a
JDBC <code class="literal">DataSource</code> and a Hibernate <code class="literal">SessionFactory</code> on top of it:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myDataSource"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">"close"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driverClassName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.hsqldb.jdbcDriver"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:hsqldb:hsql://localhost:9001"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sa"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"mySessionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myDataSource"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mappingResources"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;list&gt;</span>
                <span class="hl-tag">&lt;value&gt;</span>product.hbm.xml<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;/list&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hibernateProperties"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>
                hibernate.dialect=org.hibernate.dialect.HSQLDialect
            <span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>Switching from a local Jakarta Commons DBCP <code class="literal">BasicDataSource</code> to a JNDI-located
<code class="literal">DataSource</code> (usually managed by an application server) is just a matter of
configuration:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myDataSource"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"java:comp/env/jdbc/myds"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>You can also access a JNDI-located <code class="literal">SessionFactory</code>, using Spring&#8217;s
<code class="literal">JndiObjectFactoryBean</code> / <code class="literal">&lt;jee:jndi-lookup&gt;</code> to retrieve and expose it. However, that
is typically not common outside of an EJB context.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-straight" href="#orm-hibernate-straight"></a>15.3.2&nbsp;Implementing DAOs based on plain Hibernate 3 API</h3></div></div></div>

<p>Hibernate 3 has a feature called contextual sessions, wherein Hibernate itself manages
one current <code class="literal">Session</code> per transaction. This is roughly equivalent to Spring&#8217;s
synchronization of one Hibernate <code class="literal">Session</code> per transaction. A corresponding DAO
implementation resembles the following example, based on the plain Hibernate API:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-keyword">private</span> SessionFactory sessionFactory;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSessionFactory(SessionFactory sessionFactory) {
        <span class="hl-keyword">this</span>.sessionFactory = sessionFactory;
    }

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.sessionFactory.getCurrentSession()
                .createQuery(<span class="hl-string">"from test.Product product where product.category=?"</span>)
                .setParameter(<span class="hl-number">0</span>, category)
                .list();
    }
}</pre>

<p>This style is similar to that of the Hibernate reference documentation and examples,
except for holding the <code class="literal">SessionFactory</code> in an instance variable. We strongly recommend
such an instance-based setup over the old-school <code class="literal">static</code> <code class="literal">HibernateUtil</code> class from
Hibernate&#8217;s CaveatEmptor sample application. (In general, do not keep any resources in
<code class="literal">static</code> variables unless <span class="emphasis"><em>absolutely</em></span> necessary.)</p>
<p>The above DAO follows the dependency injection pattern: it fits nicely into a Spring IoC
container, just as it would if coded against Spring&#8217;s <code class="literal">HibernateTemplate</code>. Of course,
such a DAO can also be set up in plain Java (for example, in unit tests). Simply
instantiate it and call <code class="literal">setSessionFactory(..)</code> with the desired factory reference. As a
Spring bean definition, the DAO would resemble the following:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"mySessionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>The main advantage of this DAO style is that it depends on Hibernate API only; no import
of any Spring class is required. This is of course appealing from a non-invasiveness
perspective, and will no doubt feel more natural to Hibernate developers.</p>
<p>However, the DAO throws plain <code class="literal">HibernateException</code> (which is unchecked, so does not have
to be declared or caught), which means that callers can only treat exceptions as
generally fatal - unless they want to depend on Hibernate&#8217;s own exception hierarchy.
Catching specific causes such as an optimistic locking failure is not possible without
tying the caller to the implementation strategy. This trade off might be acceptable to
applications that are strongly Hibernate-based and/or do not need any special exception
treatment.</p>
<p>Fortunately, Spring&#8217;s <code class="literal">LocalSessionFactoryBean</code> supports Hibernate&#8217;s
<code class="literal">SessionFactory.getCurrentSession()</code> method for any Spring transaction strategy,
returning the current Spring-managed transactional <code class="literal">Session</code> even with
<code class="literal">HibernateTransactionManager</code>. Of course, the standard behavior of that method remains
the return of the current <code class="literal">Session</code> associated with the ongoing JTA transaction, if any.
This behavior applies regardless of whether you are using Spring&#8217;s
<code class="literal">JtaTransactionManager</code>, EJB container managed transactions (CMTs), or JTA.</p>
<p>In summary: you can implement DAOs based on the plain Hibernate 3 API, while still being
able to participate in Spring-managed transactions.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-declarative" href="#orm-hibernate-tx-declarative"></a>15.3.3&nbsp;Declarative transaction demarcation</h3></div></div></div>

<p>We recommend that you use Spring&#8217;s declarative transaction support, which enables you to
replace explicit transaction demarcation API calls in your Java code with an AOP
transaction interceptor. This transaction interceptor can be configured in a Spring
container using either Java annotations or XML.This declarative transaction capability
allows you to keep business services free of repetitive transaction demarcation code and
to focus on adding business logic, which is the real value of your application.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Prior to continuing, you are <span class="emphasis"><em>strongly</em></span> encouraged to read <a class="xref" href="transaction.html#transaction-declarative" title="12.5&nbsp;Declarative transaction management">Section&nbsp;12.5, &#8220;Declarative transaction management&#8221;</a>
if you have not done so.</p>
</td></tr></table></div>

<p>Furthermore, transaction semantics like propagation behavior and isolation level can be
changed in a configuration file and do not affect the business service implementations.</p>
<p>The following example shows how you can configure an AOP transaction interceptor, using
XML, for a simple service class:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">"http://www.springframework.org/schema/aop"</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- SessionFactory, DataSource, etc. omitted --&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sessionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>
        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"productServiceMethods"</span>
                <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* product.ProductService.*(..))"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"productServiceMethods"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/aop:config&gt;</span>

    <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"myTxManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;tx:attributes&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"increasePrice*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"someOtherBusinessMethod"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRES_NEW"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"SUPPORTS"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.SimpleProductService"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>This is the service class that is advised:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

    <span class="hl-keyword">private</span> ProductDao productDao;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
        <span class="hl-keyword">this</span>.productDao = productDao;
    }

    <span class="hl-comment">// notice the absence of transaction demarcation code in this method</span>
    <span class="hl-comment">// Spring's declarative transaction infrastructure will be demarcating</span>
    <span class="hl-comment">// transactions on your behalf</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
        List productsToChange = <span class="hl-keyword">this</span>.productDao.loadProductsByCategory(category);
        <span class="hl-comment">// ...</span>
    }
}</pre>

<p>We also show an attribute-support based configuration, in the following example. You
annotate the service layer with @Transactional annotations and instruct the Spring
container to find these annotations and provide transactional semantics for these
annotated methods.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

    <span class="hl-keyword">private</span> ProductDao productDao;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
        <span class="hl-keyword">this</span>.productDao = productDao;
    }

    <em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
        List productsToChange = <span class="hl-keyword">this</span>.productDao.loadProductsByCategory(category);
        <span class="hl-comment">// ...</span>
    }

    <em><span class="hl-annotation" style="color: gray">@Transactional(readOnly = true)</span></em>
    <span class="hl-keyword">public</span> List&lt;Product&gt; findAllProducts() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.productDao.findAllProducts();
    }

}</pre>

<p>As you can see from the following configuration example, the configuration is much
simplified, compared to the XML example above, while still providing the same
functionality driven by the annotations in the service layer code. All you need to
provide is the TransactionManager implementation and a "&lt;tx:annotation-driven/&gt;" entry.</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">"http://www.springframework.org/schema/aop"</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- SessionFactory, DataSource, etc. omitted --&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sessionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;tx:annotation-driven/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.SimpleProductService"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-programmatic" href="#orm-hibernate-tx-programmatic"></a>15.3.4&nbsp;Programmatic transaction demarcation</h3></div></div></div>

<p>You can demarcate transactions in a higher level of the application, on top of such
lower-level data access services spanning any number of operations. Nor do restrictions
exist on the implementation of the surrounding business service; it just needs a Spring
<code class="literal">PlatformTransactionManager</code>. Again, the latter can come from anywhere, but preferably
as a bean reference through a <code class="literal">setTransactionManager(..)</code> method, just as the
<code class="literal">productDAO</code> should be set by a <code class="literal">setProductDao(..)</code> method. The following snippets show
a transaction manager and a business service definition in a Spring application context,
and an example for a business method implementation:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTxManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"mySessionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductServiceImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myTxManager"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

    <span class="hl-keyword">private</span> TransactionTemplate transactionTemplate;
    <span class="hl-keyword">private</span> ProductDao productDao;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTransactionManager(PlatformTransactionManager transactionManager) {
        <span class="hl-keyword">this</span>.transactionTemplate = <span class="hl-keyword">new</span> TransactionTemplate(transactionManager);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
        <span class="hl-keyword">this</span>.productDao = productDao;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
        <span class="hl-keyword">this</span>.transactionTemplate.execute(<span class="hl-keyword">new</span> TransactionCallbackWithoutResult() {
            <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doInTransactionWithoutResult(TransactionStatus status) {
                List productsToChange = <span class="hl-keyword">this</span>.productDao.loadProductsByCategory(category);
                <span class="hl-comment">// do the price increase...</span>
            }
        });
    }
}</pre>

<p>Spring&#8217;s <code class="literal">TransactionInterceptor</code> allows any checked application exception to be thrown
with the callback code, while <code class="literal">TransactionTemplate</code> is restricted to unchecked
exceptions within the callback. <code class="literal">TransactionTemplate</code> triggers a rollback in case of an
unchecked application exception, or if the transaction is marked rollback-only by the
application (via <code class="literal">TransactionStatus</code>). <code class="literal">TransactionInterceptor</code> behaves the same way by
default but allows configurable rollback policies per method.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-strategies" href="#orm-hibernate-tx-strategies"></a>15.3.5&nbsp;Transaction management strategies</h3></div></div></div>

<p>Both <code class="literal">TransactionTemplate</code> and <code class="literal">TransactionInterceptor</code> delegate the actual transaction
handling to a <code class="literal">PlatformTransactionManager</code> instance, which can be a
<code class="literal">HibernateTransactionManager</code> (for a single Hibernate <code class="literal">SessionFactory</code>, using a
<code class="literal">ThreadLocal</code> <code class="literal">Session</code> under the hood) or a <code class="literal">JtaTransactionManager</code> (delegating to the
JTA subsystem of the container) for Hibernate applications. You can even use a custom
<code class="literal">PlatformTransactionManager</code> implementation. Switching from native Hibernate transaction
management to JTA, such as when facing distributed transaction requirements for certain
deployments of your application, is just a matter of configuration. Simply replace
the Hibernate transaction manager with Spring&#8217;s JTA transaction implementation. Both
transaction demarcation and data access code will work without changes, because they
just use the generic transaction management APIs.</p>
<p>For distributed transactions across multiple Hibernate session factories, simply combine
<code class="literal">JtaTransactionManager</code> as a transaction strategy with multiple
<code class="literal">LocalSessionFactoryBean</code> definitions. Each DAO then gets one specific <code class="literal">SessionFactory</code>
reference passed into its corresponding bean property. If all underlying JDBC data
sources are transactional container ones, a business service can demarcate transactions
across any number of DAOs and any number of session factories without special regard, as
long as it is using <code class="literal">JtaTransactionManager</code> as the strategy.</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource1"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"java:comp/env/jdbc/myds1"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource2"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"java:comp/env/jdbc/myds2"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"mySessionFactory1"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myDataSource1"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mappingResources"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;list&gt;</span>
                <span class="hl-tag">&lt;value&gt;</span>product.hbm.xml<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;/list&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hibernateProperties"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>
                hibernate.dialect=org.hibernate.dialect.MySQLDialect
                hibernate.show_sql=true
            <span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"mySessionFactory2"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myDataSource2"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mappingResources"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;list&gt;</span>
                <span class="hl-tag">&lt;value&gt;</span>inventory.hbm.xml<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;/list&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hibernateProperties"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>
                hibernate.dialect=org.hibernate.dialect.OracleDialect
            <span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTxManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.transaction.jta.JtaTransactionManager"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"mySessionFactory1"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myInventoryDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.InventoryDaoImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"mySessionFactory2"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductServiceImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"inventoryDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myInventoryDao"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>
        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"productServiceMethods"</span>
                <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* product.ProductService.*(..))"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"productServiceMethods"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/aop:config&gt;</span>

    <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"myTxManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;tx:attributes&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"increasePrice*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"someOtherBusinessMethod"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRES_NEW"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"SUPPORTS"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>Both <code class="literal">HibernateTransactionManager</code> and <code class="literal">JtaTransactionManager</code> allow for proper
JVM-level cache handling with Hibernate, without container-specific transaction manager
lookup or a JCA connector (if you are not using EJB to initiate transactions).</p>
<p><code class="literal">HibernateTransactionManager</code> can export the Hibernate JDBC <code class="literal">Connection</code> to plain JDBC
access code, for a specific <code class="literal">DataSource</code>. This capability allows for high-level
transaction demarcation with mixed Hibernate and JDBC data access completely without
JTA, if you are accessing only one database. <code class="literal">HibernateTransactionManager</code> automatically
exposes the Hibernate transaction as a JDBC transaction if you have set up the passed-in
<code class="literal">SessionFactory</code> with a <code class="literal">DataSource</code> through the <code class="literal">dataSource</code> property of the
<code class="literal">LocalSessionFactoryBean</code> class. Alternatively, you can specify explicitly the
<code class="literal">DataSource</code> for which the transactions are supposed to be exposed through the
<code class="literal">dataSource</code> property of the <code class="literal">HibernateTransactionManager</code> class.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-resources" href="#orm-hibernate-resources"></a>15.3.6&nbsp;Comparing container-managed and locally defined resources</h3></div></div></div>

<p>You can switch between a container-managed JNDI <code class="literal">SessionFactory</code> and a locally defined
one, without having to change a single line of application code. Whether to keep
resource definitions in the container or locally within the application is mainly a
matter of the transaction strategy that you use. Compared to a Spring-defined local
<code class="literal">SessionFactory</code>, a manually registered JNDI <code class="literal">SessionFactory</code> does not provide any
benefits. Deploying a <code class="literal">SessionFactory</code> through Hibernate&#8217;s JCA connector provides the
added value of participating in the Java EE server&#8217;s management infrastructure, but does
not add actual value beyond that.</p>
<p>Spring&#8217;s transaction support is not bound to a container. Configured with any strategy
other than JTA, transaction support also works in a stand-alone or test environment.
Especially in the typical case of single-database transactions, Spring&#8217;s single-resource
local transaction support is a lightweight and powerful alternative to JTA. When you use
local EJB stateless session beans to drive transactions, you depend both on an EJB
container and JTA, even if you access only a single database, and only use stateless
session beans to provide declarative transactions through container-managed
transactions. Also, direct use of JTA programmatically requires a Java EE environment as
well. JTA does not involve only container dependencies in terms of JTA itself and of
JNDI <code class="literal">DataSource</code> instances. For non-Spring, JTA-driven Hibernate transactions, you have
to use the Hibernate JCA connector, or extra Hibernate transaction code with the
<code class="literal">TransactionManagerLookup</code> configured for proper JVM-level caching.</p>
<p>Spring-driven transactions can work as well with a locally defined Hibernate
<code class="literal">SessionFactory</code> as they do with a local JDBC <code class="literal">DataSource</code> if they are accessing a
single database. Thus you only have to use Spring&#8217;s JTA transaction strategy when you
have distributed transaction requirements. A JCA connector requires container-specific
deployment steps, and obviously JCA support in the first place. This configuration
requires more work than deploying a simple web application with local resource
definitions and Spring-driven transactions. Also, you often need the Enterprise Edition
of your container if you are using, for example, WebLogic Express, which does not
provide JCA. A Spring application with local resources and transactions spanning one
single database works in any Java EE web container (without JTA, JCA, or EJB) such as
Tomcat, Resin, or even plain Jetty. Additionally, you can easily reuse such a middle
tier in desktop applications or test suites.</p>
<p>All things considered, if you do not use EJBs, stick with local <code class="literal">SessionFactory</code> setup
and Spring&#8217;s <code class="literal">HibernateTransactionManager</code> or <code class="literal">JtaTransactionManager</code>. You get all of
the benefits, including proper transactional JVM-level caching and distributed
transactions, without the inconvenience of container deployment. JNDI registration of a
Hibernate <code class="literal">SessionFactory</code> through the JCA connector only adds value when used in
conjunction with EJBs.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-invalid-jdbc-access-error" href="#orm-hibernate-invalid-jdbc-access-error"></a>15.3.7&nbsp;Spurious application server warnings with Hibernate</h3></div></div></div>

<p>In some JTA environments with very strict <code class="literal">XADataSource</code> implementations&#8201;&#8212;&#8201;currently
only some WebLogic Server and WebSphere versions&#8201;&#8212;&#8201;when Hibernate is configured without
regard to the JTA <code class="literal">PlatformTransactionManager</code> object for that environment, it is
possible for spurious warning or exceptions to show up in the application server log.
These warnings or exceptions indicate that the connection being accessed is no longer
valid, or JDBC access is no longer valid, possibly because the transaction is no longer
active. As an example, here is an actual exception from WebLogic:</p>

<pre class="literallayout">java.sql.SQLException: The transaction is no longer active - status: <span class="emphasis"><em>Committed</em></span>. No
further JDBC access is allowed within this transaction.</pre>

<p>You resolve this warning by simply making Hibernate aware of the JTA
<code class="literal">PlatformTransactionManager</code> instance, to which it will synchronize (along with Spring).
You have two options for doing this:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
If in your application context you are already directly obtaining the JTA
<code class="literal">PlatformTransactionManager</code> object (presumably from JNDI through
<code class="literal">JndiObjectFactoryBean</code> or <code class="literal">&lt;jee:jndi-lookup&gt;</code>) and feeding it, for example, to
Spring&#8217;s <code class="literal">JtaTransactionManager</code>, then the easiest way is to specify a reference to
the bean defining this JTA <code class="literal">PlatformTransactionManager</code> instance as the value of the
<code class="literal">jtaTransactionManager</code> property for <code class="literal">LocalSessionFactoryBean.</code> Spring then makes the
object available to Hibernate.
</li><li class="listitem">
More likely you do not already have the JTA <code class="literal">PlatformTransactionManager</code> instance,
because Spring&#8217;s <code class="literal">JtaTransactionManager</code> can find it itself. Thus you need to
configure Hibernate to look up JTA <code class="literal">PlatformTransactionManager</code> directly. You do this
by configuring an application server- specific <code class="literal">TransactionManagerLookup</code> class in the
Hibernate configuration, as described in the Hibernate manual.
</li></ul></div>

<p>The remainder of this section describes the sequence of events that occur with and
without Hibernate&#8217;s awareness of the JTA <code class="literal">PlatformTransactionManager</code>.</p>
<p>When Hibernate is not configured with any awareness of the JTA
<code class="literal">PlatformTransactionManager</code>, the following events occur when a JTA transaction commits:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The JTA transaction commits.
</li><li class="listitem">
Spring&#8217;s <code class="literal">JtaTransactionManager</code> is synchronized to the JTA transaction, so it is
called back through an <span class="emphasis"><em>afterCompletion</em></span> callback by the JTA transaction manager.
</li><li class="listitem">
Among other activities, this synchronization can trigger a callback by Spring to
Hibernate, through Hibernate&#8217;s <code class="literal">afterTransactionCompletion</code> callback (used to clear
the Hibernate cache), followed by an explicit <code class="literal">close()</code> call on the Hibernate Session,
which causes Hibernate to attempt to <code class="literal">close()</code> the JDBC Connection.
</li><li class="listitem">
In some environments, this <code class="literal">Connection.close()</code> call then triggers the warning or
error, as the application server no longer considers the <code class="literal">Connection</code> usable at all,
because the transaction has already been committed.
</li></ul></div>

<p>When Hibernate is configured with awareness of the JTA <code class="literal">PlatformTransactionManager</code>, the
following events occur when a JTA transaction commits:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the JTA transaction is ready to commit.
</li><li class="listitem">
Spring&#8217;s <code class="literal">JtaTransactionManager</code> is synchronized to the JTA transaction, so the
transaction is called back through a <span class="emphasis"><em>beforeCompletion</em></span> callback by the JTA
transaction manager.
</li><li class="listitem">
Spring is aware that Hibernate itself is synchronized to the JTA transaction, and
behaves differently than in the previous scenario. Assuming the Hibernate <code class="literal">Session</code>
needs to be closed at all, Spring will close it now.
</li><li class="listitem">
The JTA transaction commits.
</li><li class="listitem">
Hibernate is synchronized to the JTA transaction, so the transaction is called back
through an <span class="emphasis"><em>afterCompletion</em></span> callback by the JTA transaction manager, and can
properly clear its cache.
</li></ul></div>

</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jdo" href="#orm-jdo"></a>15.4&nbsp;JDO</h2></div></div></div>

<p>Spring supports the standard JDO 2.0 and 2.1 APIs as data access strategy, following the
same style as the Hibernate support. The corresponding integration classes reside in the
<code class="literal">org.springframework.orm.jdo</code> package.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-setup" href="#orm-jdo-setup"></a>15.4.1&nbsp;PersistenceManagerFactory setup</h3></div></div></div>

<p>Spring provides a <code class="literal">LocalPersistenceManagerFactoryBean</code> class that allows you to define a
local JDO <code class="literal">PersistenceManagerFactory</code> within a Spring application context:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myPmf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"configLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath:kodo.properties"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>Alternatively, you can set up a <code class="literal">PersistenceManagerFactory</code> through direct instantiation
of a <code class="literal">PersistenceManagerFactory</code> implementation class. A JDO <code class="literal">PersistenceManagerFactory</code>
implementation class follows the JavaBeans pattern, just like a JDBC <code class="literal">DataSource</code>
implementation class, which is a natural fit for a configuration that uses Spring. This
setup style usually supports a Spring-defined JDBC <code class="literal">DataSource</code>, passed into the
<code class="literal">connectionFactory</code> property. For example, for the open source JDO implementation
DataNucleus (formerly JPOX) ( <a class="ulink" href="http://www.datanucleus.org/" target="_top">http://www.datanucleus.org/</a>),
this is the XML configuration of the <code class="literal">PersistenceManagerFactory</code> implementation:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

 <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">"close"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driverClassName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.driverClassName}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.url}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.username}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.password}"</span><span class="hl-tag">/&gt;</span>
 <span class="hl-tag">&lt;/bean&gt;</span>

 <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myPmf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.datanucleus.jdo.JDOPersistenceManagerFactory"</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">"close"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"nontransactionalRead"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
 <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>You can also set up JDO <code class="literal">PersistenceManagerFactory</code> in the JNDI environment of a Java EE
application server, usually through the JCA connector provided by the particular JDO
implementation. Spring&#8217;s standard <code class="literal">JndiObjectFactoryBean</code> or <code class="literal">&lt;jee:jndi-lookup&gt;</code> can be
used to retrieve and expose such a <code class="literal">PersistenceManagerFactory</code>. However, outside an EJB
context, no real benefit exists in holding the <code class="literal">PersistenceManagerFactory</code> in JNDI: only
choose such a setup for a good reason. See <a class="xref" href="orm.html#orm-hibernate-resources" title="15.3.6&nbsp;Comparing container-managed and locally defined resources">Section&nbsp;15.3.6, &#8220;Comparing container-managed and locally defined resources&#8221;</a> for a discussion;
the arguments there apply to JDO as well.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-daos-straight" href="#orm-jdo-daos-straight"></a>15.4.2&nbsp;Implementing DAOs based on the plain JDO API</h3></div></div></div>

<p>DAOs can also be written directly against plain JDO API, without any Spring
dependencies, by using an injected <code class="literal">PersistenceManagerFactory</code>. The following is an
example of a corresponding DAO implementation:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-keyword">private</span> PersistenceManagerFactory persistenceManagerFactory;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        <span class="hl-keyword">this</span>.persistenceManagerFactory = pmf;
    }

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        PersistenceManager pm = <span class="hl-keyword">this</span>.persistenceManagerFactory.getPersistenceManager();
        <span class="hl-keyword">try</span> {
            Query query = pm.newQuery(Product.<span class="hl-keyword">class</span>, <span class="hl-string">"category = pCategory"</span>);
            query.declareParameters(<span class="hl-string">"String pCategory"</span>);
            <span class="hl-keyword">return</span> query.execute(category);
        }
        <span class="hl-keyword">finally</span> {
            pm.close();
        }
    }
}</pre>

<p>Because the above DAO follows the dependency injection pattern, it fits nicely into a
Spring container, just as it would if coded against Spring&#8217;s <code class="literal">JdoTemplate</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceManagerFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myPmf"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>The main problem with such DAOs is that they always get a new <code class="literal">PersistenceManager</code> from
the factory. To access a Spring-managed transactional <code class="literal">PersistenceManager</code>, define a
<code class="literal">TransactionAwarePersistenceManagerFactoryProxy</code> (as included in Spring) in front of
your target <code class="literal">PersistenceManagerFactory</code>, then passing a reference to that proxy into
your DAOs as in the following example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myPmfProxy"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"targetPersistenceManagerFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myPmf"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceManagerFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myPmfProxy"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>Your data access code will receive a transactional <code class="literal">PersistenceManager</code> (if any) from
the <code class="literal">PersistenceManagerFactory.getPersistenceManager()</code> method that it calls. The latter
method call goes through the proxy, which first checks for a current transactional
<code class="literal">PersistenceManager</code> before getting a new one from the factory. Any <code class="literal">close()</code> calls on
the <code class="literal">PersistenceManager</code> are ignored in case of a transactional <code class="literal">PersistenceManager</code>.</p>
<p>If your data access code always runs within an active transaction (or at least within
active transaction synchronization), it is safe to omit the <code class="literal">PersistenceManager.close()</code>
call and thus the entire <code class="literal">finally</code> block, which you might do to keep your DAO
implementations concise:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-keyword">private</span> PersistenceManagerFactory persistenceManagerFactory;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        <span class="hl-keyword">this</span>.persistenceManagerFactory = pmf;
    }

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        PersistenceManager pm = <span class="hl-keyword">this</span>.persistenceManagerFactory.getPersistenceManager();
        Query query = pm.newQuery(Product.<span class="hl-keyword">class</span>, <span class="hl-string">"category = pCategory"</span>);
        query.declareParameters(<span class="hl-string">"String pCategory"</span>);
        <span class="hl-keyword">return</span> query.execute(category);
    }
}</pre>

<p>With such DAOs that rely on active transactions, it is recommended that you enforce
active transactions through turning off
<code class="literal">TransactionAwarePersistenceManagerFactoryProxy</code>'s <code class="literal">allowCreate</code> flag:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myPmfProxy"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"targetPersistenceManagerFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myPmf"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"allowCreate"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"false"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceManagerFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myPmfProxy"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>The main advantage of this DAO style is that it depends on JDO API only; no import of
any Spring class is required. This is of course appealing from a non-invasiveness
perspective, and might feel more natural to JDO developers.</p>
<p>However, the DAO throws plain <code class="literal">JDOException</code> (which is unchecked, so does not have to be
declared or caught), which means that callers can only treat exceptions as fatal, unless
you want to depend on JDO&#8217;s own exception structure. Catching specific causes such as an
optimistic locking failure is not possible without tying the caller to the
implementation strategy. This trade off might be acceptable to applications that are
strongly JDO-based and/or do not need any special exception treatment.</p>
<p>In summary, you can DAOs based on the plain JDO API, and they can still participate in
Spring-managed transactions. This strategy might appeal to you if you are already
familiar with JDO. However, such DAOs throw plain <code class="literal">JDOException</code>, and you would have to
convert explicitly to Spring&#8217;s <code class="literal">DataAccessException</code> (if desired).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-tx" href="#orm-jdo-tx"></a>15.4.3&nbsp;Transaction management</h3></div></div></div>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>You are <span class="emphasis"><em>strongly</em></span> encouraged to read <a class="xref" href="transaction.html#transaction-declarative" title="12.5&nbsp;Declarative transaction management">Section&nbsp;12.5, &#8220;Declarative transaction management&#8221;</a> if you have not done
so, to get a more detailed coverage of Spring&#8217;s declarative transaction support.</p>
</td></tr></table></div>

<p>To execute service operations within transactions, you can use Spring&#8217;s common
declarative transaction facilities. For example:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">"http://www.springframework.org/schema/aop"</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTxManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jdo.JdoTransactionManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceManagerFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myPmf"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductServiceImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"txManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;tx:attributes&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"increasePrice*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"someOtherBusinessMethod"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRES_NEW"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"SUPPORTS"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>
        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"productServiceMethods"</span>
                <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* product.ProductService.*(..))"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"productServiceMethods"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>JDO requires an active transaction to modify a persistent object. The non-transactional
flush concept does not exist in JDO, in contrast to Hibernate. For this reason, you need
to set up the chosen JDO implementation for a specific environment. Specifically, you
need to set it up explicitly for JTA synchronization, to detect an active JTA
transaction itself. This is not necessary for local transactions as performed by
Spring&#8217;s <code class="literal">JdoTransactionManager</code>, but it is necessary to participate in JTA
transactions, whether driven by Spring&#8217;s <code class="literal">JtaTransactionManager</code> or by EJB CMT and plain
JTA.</p>
<p><code class="literal">JdoTransactionManager</code> is capable of exposing a JDO transaction to JDBC access code
that accesses the same JDBC <code class="literal">DataSource</code>, provided that the registered <code class="literal">JdoDialect</code>
supports retrieval of the underlying JDBC <code class="literal">Connection</code>. This is the case for JDBC-based
JDO 2.0 implementations by default.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-dialect" href="#orm-jdo-dialect"></a>15.4.4&nbsp;JdoDialect</h3></div></div></div>

<p>As an advanced feature, both <code class="literal">JdoTemplate</code> and <code class="literal">JdoTransactionManager</code> support a custom
<code class="literal">JdoDialect</code> that can be passed into the <code class="literal">jdoDialect</code> bean property. In this scenario,
the DAOs will not receive a <code class="literal">PersistenceManagerFactory</code> reference but rather a full
<code class="literal">JdoTemplate</code> instance (for example, passed into the <code class="literal">jdoTemplate</code> property of
<code class="literal">JdoDaoSupport</code>). Using a <code class="literal">JdoDialect</code> implementation, you can enable advanced features
supported by Spring, usually in a vendor-specific manner:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Applying specific transaction semantics such as custom isolation level or transaction
timeout
</li><li class="listitem">
Retrieving the transactional JDBC <code class="literal">Connection</code> for exposure to JDBC-based DAOs
</li><li class="listitem">
Applying query timeouts, which are automatically calculated from Spring-managed
transaction timeouts
</li><li class="listitem">
Eagerly flushing a <code class="literal">PersistenceManager,</code> to make transactional changes visible to
JDBC-based data access code
</li><li class="listitem">
Advanced translation of <code class="literal">JDOExceptions</code> to Spring <code class="literal">DataAccessExceptions</code>
</li></ul></div>

<p>See the <code class="literal">JdoDialect</code> javadocs for more details on its operations and how to use them
within Spring&#8217;s JDO support.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jpa" href="#orm-jpa"></a>15.5&nbsp;JPA</h2></div></div></div>

<p>The Spring JPA, available under the <code class="literal">org.springframework.orm.jpa</code> package, offers
comprehensive support for the
<a class="ulink" href="http://www.oracle.com/technetwork/articles/javaee/jpa-137156.html" target="_top">Java Persistence
API</a> in a similar manner to the integration with Hibernate or JDO, while being aware of
the underlying implementation in order to provide additional features.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-setup" href="#orm-jpa-setup"></a>15.5.1&nbsp;Three options for JPA setup in a Spring environment</h3></div></div></div>

<p>The Spring JPA support offers three ways of setting up the JPA <code class="literal">EntityManagerFactory</code>
that will be used by the application to obtain an entity manager.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-setup-lemfb" href="#orm-jpa-setup-lemfb"></a>LocalEntityManagerFactoryBean</h4></div></div></div>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Only use this option in simple deployment environments such as stand-alone applications
and integration tests.</p>
</td></tr></table></div>

<p>The <code class="literal">LocalEntityManagerFactoryBean</code> creates an <code class="literal">EntityManagerFactory</code> suitable for
simple deployment environments where the application uses only JPA for data access. The
factory bean uses the JPA <code class="literal">PersistenceProvider</code> autodetection mechanism (according to
JPA&#8217;s Java SE bootstrapping) and, in most cases, requires you to specify only the
persistence unit name:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myEmf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.LocalEntityManagerFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceUnitName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"myPersistenceUnit"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>This form of JPA deployment is the simplest and the most limited. You cannot refer to an
existing JDBC <code class="literal">DataSource</code> bean definition and no support for global transactions
exists. Furthermore, weaving (byte-code transformation) of persistent classes is
provider-specific, often requiring a specific JVM agent to specified on startup. This
option is sufficient only for stand-alone applications and test environments, for which
the JPA specification is designed.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-setup-jndi" href="#orm-jpa-setup-jndi"></a>Obtaining an EntityManagerFactory from JNDI</h4></div></div></div>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Use this option when deploying to a Java EE 5 server. Check your server&#8217;s documentation
on how to deploy a custom JPA provider into your server, allowing for a different
provider than the server&#8217;s default.</p>
</td></tr></table></div>

<p>Obtaining an <code class="literal">EntityManagerFactory</code> from JNDI (for example in a Java EE 5 environment),
is simply a matter of changing the XML configuration:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myEmf"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"persistence/myPersistenceUnit"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>This action assumes standard Java EE 5 bootstrapping: the Java EE server autodetects
persistence units (in effect, <code class="literal">META-INF/persistence.xml</code> files in application jars) and
<code class="literal">persistence-unit-ref</code> entries in the Java EE deployment descriptor (for example,
<code class="literal">web.xml</code>) and defines environment naming context locations for those persistence units.</p>
<p>In such a scenario, the entire persistence unit deployment, including the weaving
(byte-code transformation) of persistent classes, is up to the Java EE server. The JDBC
<code class="literal">DataSource</code> is defined through a JNDI location in the <code class="literal">META-INF/persistence.xml</code> file;
EntityManager transactions are integrated with the server&#8217;s JTA subsystem. Spring merely
uses the obtained <code class="literal">EntityManagerFactory</code>, passing it on to application objects through
dependency injection, and managing transactions for the persistence unit, typically
through <code class="literal">JtaTransactionManager</code>.</p>
<p>If multiple persistence units are used in the same application, the bean names of such
JNDI-retrieved persistence units should match the persistence unit names that the
application uses to refer to them, for example, in <code class="literal">@PersistenceUnit</code> and
<code class="literal">@PersistenceContext</code> annotations.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-setup-lcemfb" href="#orm-jpa-setup-lcemfb"></a>LocalContainerEntityManagerFactoryBean</h4></div></div></div>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Use this option for full JPA capabilities in a Spring-based application environment.
This includes web containers such as Tomcat as well as stand-alone applications and
integration tests with sophisticated persistence requirements.</p>
</td></tr></table></div>

<p>The <code class="literal">LocalContainerEntityManagerFactoryBean</code> gives full control over
<code class="literal">EntityManagerFactory</code> configuration and is appropriate for environments where
fine-grained customization is required. The <code class="literal">LocalContainerEntityManagerFactoryBean</code>
creates a <code class="literal">PersistenceUnitInfo</code> instance based on the <code class="literal">persistence.xml</code> file, the
supplied <code class="literal">dataSourceLookup</code> strategy, and the specified <code class="literal">loadTimeWeaver</code>. It is thus
possible to work with custom data sources outside of JNDI and to control the weaving
process. The following example shows a typical bean definition for a
<code class="literal">LocalContainerEntityManagerFactoryBean</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myEmf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"someDataSource"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"loadTimeWeaver"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>The following example shows a typical <code class="literal">persistence.xml</code> file:</p>
<pre class="programlisting"><span class="hl-tag">&lt;persistence</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://java.sun.com/xml/ns/persistence"</span> <span class="hl-attribute">version</span>=<span class="hl-value">"1.0"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;persistence-unit</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myUnit"</span> <span class="hl-attribute">transaction-type</span>=<span class="hl-value">"RESOURCE_LOCAL"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;mapping-file&gt;</span>META-INF/orm.xml<span class="hl-tag">&lt;/mapping-file&gt;</span>
        <span class="hl-tag">&lt;exclude-unlisted-classes/&gt;</span>
    <span class="hl-tag">&lt;/persistence-unit&gt;</span>
<span class="hl-tag">&lt;/persistence&gt;</span></pre>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">&lt;exclude-unlisted-classes/&gt;</code> shortcut indicates that <span class="emphasis"><em>no</em></span> scanning for
annotated entity classes is supposed to occur. An explicit <span class="emphasis"><em>true</em></span> value specified -
<code class="literal">&lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes/&gt;</code> - also means no scan.
<code class="literal">&lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes/&gt;</code> does trigger a scan;
however, it is recommended to simply omit the <code class="literal">exclude-unlisted-classes</code> element
if you want entity class scanning to occur.</p>
</td></tr></table></div>

<p>Using the <code class="literal">LocalContainerEntityManagerFactoryBean</code> is the most powerful JPA setup
option, allowing for flexible local configuration within the application. It supports
links to an existing JDBC <code class="literal">DataSource</code>, supports both local and global transactions, and
so on. However, it also imposes requirements on the runtime environment, such as the
availability of a weaving-capable class loader if the persistence provider demands
byte-code transformation.</p>
<p>This option may conflict with the built-in JPA capabilities of a Java EE 5 server. In a
full Java EE 5 environment, consider obtaining your <code class="literal">EntityManagerFactory</code> from JNDI.
Alternatively, specify a custom <code class="literal">persistenceXmlLocation</code> on your
<code class="literal">LocalContainerEntityManagerFactoryBean</code> definition, for example,
META-INF/my-persistence.xml, and only include a descriptor with that name in your
application jar files. Because the Java EE 5 server only looks for default
<code class="literal">META-INF/persistence.xml</code> files, it ignores such custom persistence units and hence
avoid conflicts with a Spring-driven JPA setup upfront. (This applies to Resin 3.1, for
example.)</p>
<div class="sidebar"><div class="titlepage"><div><div><p class="title"><b>When is load-time weaving required?</b></p></div></div></div>

<p>Not all JPA providers require a JVM agent ; Hibernate is an example of one that does
not. If your provider does not require an agent or you have other alternatives, such as
applying enhancements at build time through a custom compiler or an ant task, the
load-time weaver <span class="emphasis"><em>should not</em></span> be used.</p>
</div>

<p>The <code class="literal">LoadTimeWeaver</code> interface is a Spring-provided class that allows JPA
<code class="literal">ClassTransformer</code> instances to be plugged in a specific manner, depending whether the
environment is a web container or application server. Hooking <code class="literal">ClassTransformers</code>
through an
<a class="ulink" href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html" target="_top">agent</a>
typically is not efficient. The agents work against the <span class="emphasis"><em>entire virtual machine</em></span> and
inspect <span class="emphasis"><em>every</em></span> class that is loaded, which is usually undesirable in a production
server environment.</p>
<p>Spring provides a number of <code class="literal">LoadTimeWeaver</code> implementations for various environments,
allowing <code class="literal">ClassTransformer</code> instances to be applied only <span class="emphasis"><em>per class loader</em></span> and not
per VM.</p>
<p>Refer to <a class="xref" href="aop.html#aop-aj-ltw-spring" title="Spring configuration">the section called &#8220;Spring configuration&#8221;</a> in the AOP chapter for more insight regarding the
<code class="literal">LoadTimeWeaver</code> implementations and their setup, either generic or customized to
various platforms (such as Tomcat, WebLogic, GlassFish, Resin and JBoss).</p>
<p>As described in the aforementioned section, you can configure a context-wide
<code class="literal">LoadTimeWeaver</code> using the <code class="literal">@EnableLoadTimeWeaving</code> annotation of
<code class="literal">context:load-time-weaver</code> XML element. Such a global weaver is picked up by all JPA
<code class="literal">LocalContainerEntityManagerFactoryBeans</code> automatically. This is the preferred way of
setting up a load-time weaver, delivering autodetection of the platform (WebLogic,
GlassFish, Tomcat, Resin, JBoss or VM agent) and automatic propagation of the weaver to
all weaver-aware beans:</p>
<pre class="programlisting"><span class="hl-tag">&lt;context:load-time-weaver/&gt;</span>
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"emf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span><span class="hl-tag">&gt;</span>
    ...
<span class="hl-tag">&lt;/bean&gt;</span></pre>

<p>However, if needed, one can manually specify a dedicated weaver through the
<code class="literal">loadTimeWeaver</code> property:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"emf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"loadTimeWeaver"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

<p>No matter how the LTW is configured, using this technique, JPA applications relying on
instrumentation can run in the target platform (ex: Tomcat) without needing an agent.
This is important especially when the hosting applications rely on different JPA
implementations because the JPA transformers are applied only at class loader level and
thus are isolated from each other.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-multiple-pu" href="#orm-jpa-multiple-pu"></a>Dealing with multiple persistence units</h4></div></div></div>

<p>For applications that rely on multiple persistence units locations, stored in various
JARS in the classpath, for example, Spring offers the <code class="literal">PersistenceUnitManager</code> to act as
a central repository and to avoid the persistence units discovery process, which can be
expensive. The default implementation allows multiple locations to be specified that are
parsed and later retrieved through the persistence unit name. (By default, the classpath
is searched for <code class="literal">META-INF/persistence.xml</code> files.)</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pum"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceXmlLocations"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>org/springframework/orm/jpa/domain/persistence-multi.xml<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>classpath:/my/package/**/custom-persistence.xml<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>classpath*:META-INF/persistence.xml<span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/list&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSources"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;map&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"localDataSource"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"local-db"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"remoteDataSource"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"remote-db"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-comment">&lt;!-- if no datasource is specified, use this one --&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"defaultDataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"remoteDataSource"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"emf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceUnitManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"pum"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceUnitName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"myCustomUnit"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>

<p>The default implementation allows customization of the <code class="literal">PersistenceUnitInfo</code> instances,
before they are fed to the JPA provider, declaratively through its properties, which
affect <span class="emphasis"><em>all</em></span> hosted units, or programmatically, through the
<code class="literal">PersistenceUnitPostProcessor</code>, which allows persistence unit selection. If no
<code class="literal">PersistenceUnitManager</code> is specified, one is created and used internally by
<code class="literal">LocalContainerEntityManagerFactoryBean</code>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-straight" href="#orm-jpa-straight"></a>15.5.2&nbsp;Implementing DAOs based on plain JPA</h3></div></div></div>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Although <code class="literal">EntityManagerFactory</code> instances are thread-safe, <code class="literal">EntityManager</code> instances are
not. The injected JPA <code class="literal">EntityManager</code> behaves like an <code class="literal">EntityManager</code> fetched from an
application server&#8217;s JNDI environment, as defined by the JPA specification. It delegates
all calls to the current transactional <code class="literal">EntityManager</code>, if any; otherwise, it falls back
to a newly created <code class="literal">EntityManager</code> per operation, in effect making its usage thread-safe.</p>
</td></tr></table></div>

<p>It is possible to write code against the plain JPA without any Spring dependencies, by
using an injected <code class="literal">EntityManagerFactory</code> or <code class="literal">EntityManager</code>. Spring can understand
<code class="literal">@PersistenceUnit</code> and <code class="literal">@PersistenceContext</code> annotations both at field and method level
if a <code class="literal">PersistenceAnnotationBeanPostProcessor</code> is enabled. A plain JPA DAO implementation
using the <code class="literal">@PersistenceUnit</code> annotation might look like this:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-keyword">private</span> EntityManagerFactory emf;

    <em><span class="hl-annotation" style="color: gray">@PersistenceUnit</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setEntityManagerFactory(EntityManagerFactory emf) {
        <span class="hl-keyword">this</span>.emf = emf;
    }

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        EntityManager em = <span class="hl-keyword">this</span>.emf.createEntityManager();
        <span class="hl-keyword">try</span> {
            Query query = em.createQuery(<span class="hl-string">"from Product as p where p.category = ?1"</span>);
            query.setParameter(<span class="hl-number">1</span>, category);
            <span class="hl-keyword">return</span> query.getResultList();
        }
        <span class="hl-keyword">finally</span> {
            <span class="hl-keyword">if</span> (em != null) {
                em.close();
            }
        }
    }
}</pre>

<p>The DAO above has no dependency on Spring and still fits nicely into a Spring
application context. Moreover, the DAO takes advantage of annotations to require the
injection of the default <code class="literal">EntityManagerFactory</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-comment">&lt;!-- bean post-processor for JPA annotations --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>As an alternative to defining a <code class="literal">PersistenceAnnotationBeanPostProcessor</code> explicitly,
consider using the Spring <code class="literal">context:annotation-config</code> XML element in your application
context configuration. Doing so automatically registers all Spring standard
post-processors for annotation-based configuration, including
<code class="literal">CommonAnnotationBeanPostProcessor</code> and so on.</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-comment">&lt;!-- post-processors for all standard config annotations --&gt;</span>
    <span class="hl-tag">&lt;context:annotation-config/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>The main problem with such a DAO is that it always creates a new <code class="literal">EntityManager</code> through
the factory. You can avoid this by requesting a transactional <code class="literal">EntityManager</code> (also
called "shared EntityManager" because it is a shared, thread-safe proxy for the actual
transactional EntityManager) to be injected instead of the factory:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <em><span class="hl-annotation" style="color: gray">@PersistenceContext</span></em>
    <span class="hl-keyword">private</span> EntityManager em;

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        Query query = em.createQuery(<span class="hl-string">"from Product as p where p.category = :category"</span>);
        query.setParameter(<span class="hl-string">"category"</span>, category);
        <span class="hl-keyword">return</span> query.getResultList();
    }
}</pre>

<p>The <code class="literal">@PersistenceContext</code> annotation has an optional attribute <code class="literal">type</code>, which defaults to
<code class="literal">PersistenceContextType.TRANSACTION</code>. This default is what you need to receive a shared
EntityManager proxy. The alternative, <code class="literal">PersistenceContextType.EXTENDED</code>, is a completely
different affair: This results in a so-called extended EntityManager, which is <span class="emphasis"><em>not
thread-safe</em></span> and hence must not be used in a concurrently accessed component such as a
Spring-managed singleton bean. Extended EntityManagers are only supposed to be used in
stateful components that, for example, reside in a session, with the lifecycle of the
EntityManager not tied to a current transaction but rather being completely up to the
application.</p>
<div class="sidebar"><div class="titlepage"><div><div><p class="title"><b>Method- and field-level Injection</b></p></div></div></div>

<p>Annotations that indicate dependency injections (such as <code class="literal">@PersistenceUnit</code> and
<code class="literal">@PersistenceContext</code>) can be applied on field or methods inside a class, hence the
expressions <span class="emphasis"><em>method-level injection</em></span> and <span class="emphasis"><em>field-level injection</em></span>. Field-level
annotations are concise and easier to use while method-level allows for further
processing of the injected dependency. In both cases the member visibility (public,
protected, private) does not matter.</p>
<p>What about class-level annotations?</p>
<p>On the Java EE 5 platform, they are used for dependency declaration and not for resource
injection.</p>
</div>

<p>The injected <code class="literal">EntityManager</code> is Spring-managed (aware of the ongoing transaction). It is
important to note that even though the new DAO implementation uses method level
injection of an <code class="literal">EntityManager</code> instead of an <code class="literal">EntityManagerFactory</code>, no change is
required in the application context XML due to annotation usage.</p>
<p>The main advantage of this DAO style is that it only depends on Java Persistence API; no
import of any Spring class is required. Moreover, as the JPA annotations are understood,
the injections are applied automatically by the Spring container. This is appealing from
a non-invasiveness perspective, and might feel more natural to JPA developers.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-tx" href="#orm-jpa-tx"></a>15.5.3&nbsp;Transaction Management</h3></div></div></div>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>You are <span class="emphasis"><em>strongly</em></span> encouraged to read <a class="xref" href="transaction.html#transaction-declarative" title="12.5&nbsp;Declarative transaction management">Section&nbsp;12.5, &#8220;Declarative transaction management&#8221;</a> if you have not done
so, to get a more detailed coverage of Spring&#8217;s declarative transaction support.</p>
</td></tr></table></div>

<p>To execute service operations within transactions, you can use Spring&#8217;s common
declarative transaction facilities. For example:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">"http://www.springframework.org/schema/aop"</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTxManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.JpaTransactionManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"entityManagerFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myEmf"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductServiceImpl"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>
        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">"productServiceMethods"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* product.ProductService.*(..))"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">"productServiceMethods"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/aop:config&gt;</span>

    <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"myTxManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;tx:attributes&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"increasePrice*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"someOtherBusinessMethod"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRES_NEW"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"SUPPORTS"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

<p>Spring JPA allows a configured <code class="literal">JpaTransactionManager</code> to expose a JPA transaction to
JDBC access code that accesses the same JDBC <code class="literal">DataSource</code>, provided that the registered
<code class="literal">JpaDialect</code> supports retrieval of the underlying JDBC <code class="literal">Connection</code>. Out of the box,
Spring provides dialects for the Toplink, Hibernate and OpenJPA JPA implementations. See
the next section for details on the <code class="literal">JpaDialect</code> mechanism.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-dialect" href="#orm-jpa-dialect"></a>15.5.4&nbsp;JpaDialect</h3></div></div></div>

<p>As an advanced feature <code class="literal">JpaTemplate</code>, <code class="literal">JpaTransactionManager</code> and subclasses of
<code class="literal">AbstractEntityManagerFactoryBean</code> support a custom <code class="literal">JpaDialect</code>, to be passed into the
<code class="literal">jpaDialect</code> bean property. In such a scenario, the DAOs do not receive an
<code class="literal">EntityManagerFactory</code> reference but rather a full <code class="literal">JpaTemplate</code> instance (for example,
passed into the <code class="literal">jpaTemplate</code> property of <code class="literal">JpaDaoSupport</code>). A <code class="literal">JpaDialect</code>
implementation can enable some advanced features supported by Spring, usually in a
vendor-specific manner:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Applying specific transaction semantics such as custom isolation level or transaction
timeout)
</li><li class="listitem">
Retrieving the transactional JDBC <code class="literal">Connection</code> for exposure to JDBC-based DAOs)
</li><li class="listitem">
Advanced translation of <code class="literal">PersistenceExceptions</code> to Spring <code class="literal">DataAccessExceptions</code>
</li></ul></div>

<p>This is particularly valuable for special transaction semantics and for advanced
translation of exception. The default implementation used ( <code class="literal">DefaultJpaDialect</code>) does
not provide any special capabilities and if the above features are required, you have to
specify the appropriate dialect.</p>
<p>See the <code class="literal">JpaDialect</code> javadocs for more details of its operations and how they are used
within Spring&#8217;s JPA support.</p>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="jdbc.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-data-tier.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="oxm.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">14.&nbsp;Data access with JDBC&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;16.&nbsp;Marshalling XML using O/X Mappers</td></tr></table></div></body></html>